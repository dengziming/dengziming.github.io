<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>janusgraph源码分析8-底层交互 - 数据分析师之旅</title>
  <link rel="alternate" hreflang="zh-cn" href="https://dengziming.github.io/" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="邓子明" />
  <meta name="description" content="反向分析 cassandra 写数据 API cassandra 的结构类似 bigtable ，数据实际上是多层嵌套的 map，第一个 key 是 rowkey，第二层key 是 columnFamily，第三层key" />

  <meta name="keywords" content="大数据, AI, 机器学习" />






<meta name="generator" content="Hugo 0.26" />


<link rel="canonical" href="https://dengziming.github.io/post/titan/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%909-%E8%B4%A1%E7%8C%AE%E5%AF%BC%E6%95%B0%E6%8D%AE%E6%BA%90%E7%A0%81/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="janusgraph源码分析8-底层交互" />
<meta property="og:description" content="反向分析 cassandra 写数据 API cassandra 的结构类似 bigtable ，数据实际上是多层嵌套的 map，第一个 key 是 rowkey，第二层key 是 columnFamily，第三层key" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dengziming.github.io/post/titan/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%909-%E8%B4%A1%E7%8C%AE%E5%AF%BC%E6%95%B0%E6%8D%AE%E6%BA%90%E7%A0%81/" />



<meta property="article:published_time" content="2018-07-09T00:00:00&#43;00:00"/>
<meta property="article:modified_time" content="2018-07-09T00:00:00&#43;00:00"/>











<meta itemprop="name" content="janusgraph源码分析8-底层交互">
<meta itemprop="description" content="反向分析 cassandra 写数据 API cassandra 的结构类似 bigtable ，数据实际上是多层嵌套的 map，第一个 key 是 rowkey，第二层key 是 columnFamily，第三层key">


<meta itemprop="dateModified" content="2018-07-09T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="4200">



<meta itemprop="keywords" content="janusgraph,源码," />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="janusgraph源码分析8-底层交互"/>
<meta name="twitter:description" content="反向分析 cassandra 写数据 API cassandra 的结构类似 bigtable ，数据实际上是多层嵌套的 map，第一个 key 是 rowkey，第二层key 是 columnFamily，第三层key"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Dengziming</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">列表</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="https://gohugo.io">
        <li class="mobile-menu-item">站外链接</li>
      </a>
  </ul>
</nav>

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">Dengziming</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        
        <a class="menu-item-link" href="/">Home</a>
        
      </li><li class="menu-item">
        
        <a class="menu-item-link" href="/post/">列表</a>
        
      </li><li class="menu-item">
        
        <a class="menu-item-link" href="/tags/">标签</a>
        
      </li><li class="menu-item">
        
        <a class="menu-item-link" href="/categories/">分类</a>
        
      </li><li class="menu-item">
        
        <a class="menu-item-link" href="/about/">About</a>
        
      </li><li class="menu-item">
        
        <a class="menu-item-link" href="https://gohugo.io" target="_blank">
          站外链接
          <i class="iconfont icon-new-window"></i>
        </a>
        
      </li>
  </ul>
</nav>
  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">janusgraph源码分析8-底层交互</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-07-09 </span>
        <div class="post-category">
            
              <a href="/categories/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"> janusgraph源码分析 </a>
            
          </div>
        <span class="more-meta"> 4200 words </span>
        <span class="more-meta"> 9 min read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li><a href="#反向分析">反向分析</a>
<ul>
<li><a href="#cassandra-写数据-api">cassandra 写数据 API</a></li>
<li><a href="#写入-cassandra-的数据格式">写入 cassandra 的数据格式</a></li>
<li><a href="#传入-mutatemany-的数据">传入 mutateMany 的数据</a></li>
<li><a href="#mutations-的构造">mutations 的构造</a></li>
<li><a href="#mutate-方法参数来源">mutate 方法参数来源</a></li>
<li><a href="#edgeserializer-writerelation-到底做了什么">edgeSerializer.writeRelation 到底做了什么</a>
<ul>
<li><a href="#staticarrayentry">StaticArrayEntry</a></li>
<li><a href="#variablelong">VariableLong</a></li>
<li><a href="#writeinline">writeInline</a></li>
</ul></li>
<li><a href="#writerelation-方法的参数怎么构造的">writeRelation 方法的参数怎么构造的</a></li>
</ul></li>
<li><a href="#正向理清思路">正向理清思路</a>
<ul>
<li><a href="#1-janus-官网介绍">1. janus 官网介绍</a>
<ul>
<li><a href="#edge-label">Edge Label</a></li>
<li><a href="#property-keys">Property Keys</a></li>
<li><a href="#relation-types">Relation Types</a></li>
<li><a href="#vertex-labels">Vertex Labels</a></li>
<li><a href="#unidirected-edges">Unidirected Edges</a></li>
</ul></li>
<li><a href="#2-addproperty-和-addedge">2. addProperty 和 addEdge</a></li>
<li><a href="#mutateedges">mutateEdges</a></li>
<li><a href="#id-分配">id 分配</a>
<ul>
<li><a href="#vertexidassigner">VertexIDAssigner</a>
<ul>
<li><a href="#assignid">assignID</a></li>
</ul></li>
<li><a href="#standardidpool">StandardIDPool</a></li>
</ul></li>
<li><a href="#调试一次">调试一次</a></li>
</ul></li>
<li><a href="#bulk-loading">bulk loading</a>
<ul>
<li><a href="#vertex-导入">vertex 导入</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      

<h1 id="反向分析">反向分析</h1>

<h2 id="cassandra-写数据-api">cassandra 写数据 API</h2>

<p>cassandra 的结构类似 bigtable ，数据实际上是多层嵌套的 map，第一个 key 是 rowkey，第二层key 是 columnFamily，第三层key 是 column，第四层(也可以忽略) 是 timestamp，然后是 value。</p>

<p>写数据的 API 如下：</p>

<pre><code class="language-java"> CTConnection conn = null;
 try {
     conn = pool.borrowObject(keySpaceName);
     Cassandra.Client client = conn.getClient();
     if (atomicBatch) {
         client.atomic_batch_mutate(batch, consistency);
     } else {
         client.batch_mutate(batch, consistency);
     }
 } catch (Exception ex) {
     throw CassandraThriftKeyColumnValueStore.convertException(ex);
 } finally {
     pool.returnObjectUnsafe(keySpaceName, conn);
 }
</code></pre>

<p>这里的 batch 就是一个多层嵌套的map。<code>final Map&lt;ByteBuffer, Map&lt;String, List&lt;org.apache.cassandra.thrift.Mutation&gt;&gt;&gt; batch = new HashMap&lt;&gt;(size);</code></p>

<p>这里看起来只有两层，第一层的 ByteBuffer 当然是 rowKey，第二层是 String 是 columnFamily。而 <code>List&lt;org.apache.cassandra.thrift.Mutation&gt;</code> 很明显就是添加或者删除的 key:value。</p>

<h2 id="写入-cassandra-的数据格式">写入 cassandra 的数据格式</h2>

<p>上面是写 cassandra 的 API，而最终调用这段代码的位置在 <code>CassandraThriftStoreManager.mutateMany(Map&lt;String, Map&lt;StaticBuffer, KCVMutation&gt;&gt; mutations, StoreTransaction txh)</code> 方法。</p>

<p>我们需要了解的就是  <code>Map&lt;String, Map&lt;StaticBuffer, KCVMutation&gt;&gt; mutations</code> 和 <code>Map&lt;ByteBuffer, Map&lt;String, List&lt;org.apache.cassandra.thrift.Mutation&gt;&gt;&gt; batch</code> 的对应关系。</p>

<p>从代码可以看出：</p>

<pre><code class="language-java">final Map&lt;ByteBuffer, Map&lt;String, List&lt;org.apache.cassandra.thrift.Mutation&gt;&gt;&gt; batch = new HashMap&lt;&gt;(size);

for (final Map.Entry&lt;String, Map&lt;StaticBuffer, KCVMutation&gt;&gt; keyMutation : mutations.entrySet()) {
    
    // mutations 的 key 是 columnFamily
    final String columnFamily = keyMutation.getKey(); 
    
    for (final Map.Entry&lt;StaticBuffer, KCVMutation&gt; mutEntry : keyMutation.getValue().entrySet()) {
        
        // mutations 的第二层 key 是 rowKey
        ByteBuffer keyBB = mutEntry.getKey().asByteBuffer();

        // Get or create the single Cassandra Mutation object responsible for this key
        // Most mutations only modify the edgeStore and indexStore
        
        final Map&lt;String, List&lt;org.apache.cassandra.thrift.Mutation&gt;&gt; cfmutation
            = batch.computeIfAbsent(keyBB, k -&gt; new HashMap&lt;&gt;(3));

        final KCVMutation mutation = mutEntry.getValue();
        final List&lt;org.apache.cassandra.thrift.Mutation&gt; thriftMutation = new ArrayList&lt;&gt;(mutations.size());
        
        // 省略删除的代码。
        
        if (mutation.hasAdditions()) {
            
            for (final Entry ent : mutation.getAdditions()) {
                final ColumnOrSuperColumn columnOrSuperColumn = new ColumnOrSuperColumn();
                
                // mutations 的第三层 key 是 column
                final Column column = new Column(ent.getColumnAs(StaticBuffer.BB_FACTORY));
                // mutations 的 value 是 value
                column.setValue(ent.getValueAs(StaticBuffer.BB_FACTORY));

                column.setTimestamp(commitTime.getAdditionTime(times));

                final Integer ttl = (Integer) ent.getMetaData().get(EntryMetaData.TTL);
                if (null != ttl &amp;&amp; ttl &gt; 0) {
                    column.setTtl(ttl);
                }

                columnOrSuperColumn.setColumn(column);
                org.apache.cassandra.thrift.Mutation m = new org.apache.cassandra.thrift.Mutation();
                m.setColumn_or_supercolumn(columnOrSuperColumn);
                thriftMutation.add(m);
            }
        }

        cfmutation.put(columnFamily, thriftMutation);
    }
}
</code></pre>

<p>我们可以看出 mutateMany 方法的参数和写到 cassandra 的结果不是完全一致，主要是 rowkey 和 columnFamily 的位置是反的。</p>

<h2 id="传入-mutatemany-的数据">传入 mutateMany 的数据</h2>

<p>通过调试可以看出，调用 mutateMany 的地方主要是 <code>CacheTransation.persist</code> ,而调用 persist 的就是 flushInternal 方法。相应代码：</p>

<pre><code class="language-java">// 成员变量： Map&lt;KCVSCache, Map&lt;StaticBuffer, KCVEntryMutation&gt;&gt; mutations

// 新建Map，这个 map 就是上面 mutateMany 的参数，key 分别是 columnFamily 和 rowKey ，
final Map&lt;String, Map&lt;StaticBuffer, KCVMutation&gt;&gt; subMutations = new HashMap&lt;&gt;(mutations.size());

int numSubMutations = 0;
// 遍历 mutations
for (Map.Entry&lt;KCVSCache,Map&lt;StaticBuffer, KCVEntryMutation&gt;&gt; storeMutations : mutations.entrySet()) {
    final Map&lt;StaticBuffer, KCVMutation&gt; sub = new HashMap&lt;&gt;();
    
    // KCVSCache 的 getKey().getName() 就是 columnFamily
    subMutations.put(storeMutations.getKey().getName(),sub);
   
    // mutations 的 value
    for (Map.Entry&lt;StaticBuffer,KCVEntryMutation&gt; mutationsForKey : storeMutations.getValue().entrySet()) {
        if (mutationsForKey.getValue().isEmpty()) continue;
        
        // 将 mutationsForKey 放进去，这个 convert 做了啥没有具体研究，可能只是一个适配。
        sub.put(mutationsForKey.getKey(), convert(mutationsForKey.getValue()));
        numSubMutations+=mutationsForKey.getValue().getTotalMutations();
        if (numSubMutations&gt;= persistChunkSize) {
            numSubMutations = persist(subMutations);
            sub.clear();
            subMutations.put(storeMutations.getKey().getName(),sub);
        }
    }
}
</code></pre>

<h2 id="mutations-的构造">mutations 的构造</h2>

<p>上面我们看出了，其实基本上没复杂处理，接下来我们看看 mutations 数据哪里来的。</p>

<p>对于 mutations 的修改操作，来自于 mutate 方法，代码：</p>

<pre><code class="language-java">// 传入的是 store（包含了columnFamily） key（rowKey） additions 和 deletions
void mutate(KCVSCache store, StaticBuffer key, List&lt;Entry&gt; additions, List&lt;Entry&gt; deletions) throws BackendException {
    Preconditions.checkNotNull(store);
    if (additions.isEmpty() &amp;&amp; deletions.isEmpty()) return;
    
    // 构造 KCVEntryMutation
    KCVEntryMutation m = new KCVEntryMutation(additions, deletions);
    
    // 这几步就是简单的合并所以的 additions 和 deletions
    final Map&lt;StaticBuffer, KCVEntryMutation&gt; storeMutation = mutations.computeIfAbsent(store, k -&gt; new HashMap&lt;&gt;());
    KCVEntryMutation existingM = storeMutation.get(key);
    
    if (existingM != null) {
        existingM.merge(m);
    } else {
        storeMutation.put(key, m);
    }

    numMutations += m.getTotalMutations();

    if (batchLoading &amp;&amp; numMutations &gt;= persistChunkSize) {
        flushInternal();
    }
}
</code></pre>

<h2 id="mutate-方法参数来源">mutate 方法参数来源</h2>

<p>mutate 方法传入的是 store（包含了columnFamily） key（rowKey） additions 和 deletions，这几个参数哪里来的呢？ KCVSCache 的 mutateEntries，
mutateEdges 调用时机呢？ edgeStore.mutateEntries(key, additions, deletions, storeTx); indexStore.mutateEntries(key, additions, deletions, storeTx);
我们先以 edgeStore 为例，在 StandardJanusGraph 的 prepareCommit 方法中，调用了 mutator.mutateEdges(vertexKey, additions, deletions);
代码如下，我们删掉了部分代码，包括 索引和数据删除。</p>

<pre><code class="language-java">ListMultimap&lt;Long, InternalRelation&gt; mutations = ArrayListMultimap.create();
ListMultimap&lt;InternalVertex, InternalRelation&gt; mutatedProperties = ArrayListMultimap.create();
List&lt;IndexSerializer.IndexUpdate&gt; indexUpdates = Lists.newArrayList();


//2) Collect added edges and their index updates and acquire edge locks
// add 是 InternalRelation ，包括 VertexProperty 和 Edge，前面分析过，VertexProperty 实际上就是顶点和一个 schema 的订单建一条边，Edge 就是两个顶点建一条边。
for (InternalRelation add : Iterables.filter(addedRelations,filter)) {
    Preconditions.checkArgument(add.isNew());
    
    // getLen 返回这个 Relation 的长度，如果是 VertexProperty 是1，Edge 是需要根据方向进行判断
    for (int pos = 0; pos &lt; add.getLen(); pos++) {
        // 得到对应的 vertex 
        InternalVertex vertex = add.getVertex(pos);
        if (pos == 0 || !add.isLoop()) {
        
            // mutatedProperties 的 key: InternalVertex,value:InternalRelation,mutatedProperties 是用于更新索引的，在我们这里实际上没什么用。
            if (add.isProperty()) mutatedProperties.put(vertex,add);
            // mutations 的 key ： vertexId, value ： InternalRelation
            mutations.put(vertex.longId(), add);
        }
        if (!vertex.isNew() &amp;&amp; acquireLock(add,pos,acquireLocks)) {
            Entry entry = edgeSerializer.writeRelation(add, pos, tx);
            mutator.acquireEdgeLock(idManager.getKey(vertex.longId()), entry.getColumn());
        }
    }
}


//5) Add relation mutations
for (Long vertexId : mutations.keySet()) {
    Preconditions.checkArgument(vertexId &gt; 0, &quot;Vertex has no id: %s&quot;, vertexId);
    final List&lt;InternalRelation&gt; edges = mutations.get(vertexId);
    final List&lt;Entry&gt; additions = new ArrayList&lt;&gt;(edges.size());
    final List&lt;Entry&gt; deletions = new ArrayList&lt;&gt;(Math.max(10, edges.size() / 10));
    for (final InternalRelation edge : edges) {
        // 得到 InternalRelationType ，分为 PropertyKey 和 EdgeLabel 两类
        final InternalRelationType baseType = (InternalRelationType) edge.getType();
        assert baseType.getBaseType()==null;

        for (InternalRelationType type : baseType.getRelationIndexes()) { 
            if (type.getStatus()== SchemaStatus.DISABLED) continue;
            // getArity 和 getLen 不一样，
            for (int pos = 0; pos &lt; edge.getArity(); pos++) {
                if (!type.isUnidirected(Direction.BOTH) &amp;&amp; !type.isUnidirected(EdgeDirection.fromPosition(pos)))
                    continue; //Directionality is not covered
                
                // 如果是起始顶点
                if (edge.getVertex(pos).longId()==vertexId) {
                
                    // 根据 edge type pos tx 得到应该序列化的 StaticArrayEntry
                    StaticArrayEntry entry = edgeSerializer.writeRelation(edge, type, pos, tx);
                    if (edge.isRemoved()) {
                        deletions.add(entry);
                    } else {
                        Preconditions.checkArgument(edge.isNew());
                        int ttl = getTTL(edge);
                        if (ttl &gt; 0) {
                            entry.setMetaData(EntryMetaData.TTL, ttl);
                        }
                        additions.add(entry);
                    }
                }
            }
        }
    }

    StaticBuffer vertexKey = idManager.getKey(vertexId);
    mutator.mutateEdges(vertexKey, additions, deletions);
}

</code></pre>

<h2 id="edgeserializer-writerelation-到底做了什么">edgeSerializer.writeRelation 到底做了什么</h2>

<p>我们现在就想知道，数据是怎么被序列化话 entry 的，代码如下：</p>

<pre><code class="language-java">public StaticArrayEntry writeRelation(InternalRelation relation, InternalRelationType type, int position,
                                      TypeInspector tx) {
    assert type==relation.getType() || (type.getBaseType() != null
            &amp;&amp; type.getBaseType().equals(relation.getType()));
    // 得到方向，pos 是 0 就是 out，是 1 就是 in
    Direction dir = EdgeDirection.fromPosition(position);
    
    // 方向验证
    Preconditions.checkArgument(type.isUnidirected(Direction.BOTH) || type.isUnidirected(dir));
    
    // 得到 typeId， 这个 type 是 VertexLabel 或者 PropertyKey
    long typeId = type.longId();
    // 得到 dirID 
    DirectionID dirID = getDirID(dir, relation.isProperty() ? RelationCategory.PROPERTY : RelationCategory.EDGE);
    
    // 得到 一个 out
    DataOutput out = serializer.getDataOutput(DEFAULT_CAPACITY);
    // key 和 value 的分割地址。
    int valuePosition;
    
    // 写 typeId 和 dirID 
    IDHandler.writeRelationType(out, typeId, dirID, type.isInvisibleType());
    
    // 得到 multiplicity 和 sortKey
    Multiplicity multiplicity = type.multiplicity();
    long[] sortKey = type.getSortKey();
    
    assert !multiplicity.isConstrained() || sortKey.length==0: type.name();
    int keyStartPos = out.getPosition();
    if (!multiplicity.isConstrained()) {
        // 如果 multiplicity 是 没有限制，也就是为 MULTI，必须要有 sortKey，写出 sortKey。
        writeInlineTypes(sortKey, relation, out, tx, InlineType.KEY);
    }
    
    // 到这里 key 就写完了，得到 key 的 pos
    int keyEndPos = out.getPosition();

    long relationId = relation.longId();

    //How multiplicity is handled for edges and properties is slightly different
    if (relation.isEdge()) {
        // 得到另一个 vertex 的 id
        long otherVertexId = relation.getVertex((position + 1) % 2).longId();
        // 如果 multiplicity 有限制
        if (multiplicity.isConstrained()) {
            // isUnique
            if (multiplicity.isUnique(dir)) {
                // 得到 valuePosition ，写出 otherVertexId 
                valuePosition = out.getPosition();
                VariableLong.writePositive(out, otherVertexId);
            } else {
                // 反方向写 otherVertexId ,记下 valuePosition
                VariableLong.writePositiveBackward(out, otherVertexId);
                valuePosition = out.getPosition();
            }
            // 写下 relationId
            VariableLong.writePositive(out, relationId);
        } else {
            // 没有限制，反方向写出 otherVertexId 和 relationId ，记下 valuePosition
            VariableLong.writePositiveBackward(out, otherVertexId);
            VariableLong.writePositiveBackward(out, relationId);
            valuePosition = out.getPosition();
        }
    } else { // PropertyKey
        assert relation.isProperty();
        Preconditions.checkArgument(relation.isProperty());
        // 得到 property 的值。
        Object value = ((JanusGraphVertexProperty) relation).value();
        Preconditions.checkNotNull(value);
        PropertyKey key = (PropertyKey) type;
        assert key.dataType().isInstance(value);
        
        // 写出 value 得到 valuePosition
        if (multiplicity.isConstrained()) { // 没有限制的 property
            if (multiplicity.isUnique(dir)) { //Cardinality=SINGLE
                valuePosition = out.getPosition();
                writePropertyValue(out,key,value);
            } else { //Cardinality=SET
                writePropertyValue(out,key,value);
                valuePosition = out.getPosition();
            }
            VariableLong.writePositive(out, relationId);
        } else {
            assert multiplicity.getCardinality()== Cardinality.LIST;
            VariableLong.writePositiveBackward(out, relationId);
            valuePosition = out.getPosition();
            writePropertyValue(out,key,value);
        }
    }

    //Write signature
    long[] signature = type.getSignature();
    writeInlineTypes(signature, relation, out, tx, InlineType.SIGNATURE);

    //Write remaining properties
    LongSet writtenTypes = new LongHashSet(sortKey.length + signature.length);
    if (sortKey.length &gt; 0 || signature.length &gt; 0) {
        for (long id : sortKey) writtenTypes.add(id);
        for (long id : signature) writtenTypes.add(id);
    }
    LongArrayList remainingTypes = new LongArrayList(8);
    for (PropertyKey t : relation.getPropertyKeysDirect()) {
        if (!(t instanceof ImplicitKey) &amp;&amp; !writtenTypes.contains(t.longId())) {
            remainingTypes.add(t.longId());
        }
    }
    //Sort types before writing to ensure that value is always written the same way
    long[] remaining = remainingTypes.toArray();
    Arrays.sort(remaining);
    for (long tid : remaining) {
        PropertyKey t = tx.getExistingPropertyKey(tid);
        writeInline(out, t, relation.getValueDirect(t), InlineType.NORMAL);
    }
    assert valuePosition&gt;0;

    return new StaticArrayEntry(type.getSortOrder() == Order.DESC ?
                                out.getStaticBufferFlipBytes(keyStartPos, keyEndPos) :
                                out.getStaticBuffer(), valuePosition);
}
</code></pre>

<p>其实就是不断吧值写进去并且记录一下值的位置。</p>

<p>我们需要了解一下 writeInline 方法以及  StaticArrayEntry VariableLong 类。</p>

<h3 id="staticarrayentry">StaticArrayEntry</h3>

<pre><code>Entry (org.janusgraph.diskstorage)
BaseStaticArrayEntry (org.janusgraph.diskstorage.util)
StaticEntry in StaticArrayEntryList (org.janusgraph.diskstorage.util)
StaticArrayEntry (org.janusgraph.diskstorage.util)
SwappingEntry in StaticArrayEntryList (org.janusgraph.diskstorage.util)
StaticArrayEntry (org.janusgraph.diskstorage.util)
</code></pre>

<p>Entry 代表存储在 cassandra 基本结构，有 getColumn getValuePosition getValue 等方法，
BaseStaticArrayEntry 则是利用一个 array,offset,limit,valuePosition 进行封装。</p>

<h3 id="variablelong">VariableLong</h3>

<p>这个提供了一个读写Long类型的数据的方法，具体后续研究。</p>

<h3 id="writeinline">writeInline</h3>

<p>writeInline 方法实现：</p>

<pre><code class="language-java">private void writeInlineTypes(long[] keyIds, InternalRelation relation, DataOutput out, TypeInspector tx,
                              InlineType inlineType) {
    for (long keyId : keyIds) {
        PropertyKey t = tx.getExistingPropertyKey(keyId);
        writeInline(out, t, relation.getValueDirect(t), inlineType);
    }
}

private void writeInline(DataOutput out, PropertyKey inlineKey, Object value, InlineType inlineType) {
    assert inlineType.writeInlineKey() || !AttributeUtil.hasGenericDataType(inlineKey);

    if (inlineType.writeInlineKey()) {
        IDHandler.writeInlineRelationType(out, inlineKey.longId());
    }

    writePropertyValue(out,inlineKey,value, inlineType);
}

private void writePropertyValue(DataOutput out, PropertyKey key, Object value, InlineType inlineType) {
    if (AttributeUtil.hasGenericDataType(key)) {
        assert !inlineType.writeByteOrdered();
        out.writeClassAndObject(value);
    } else {
        assert value==null || value.getClass().equals(key.dataType());
        if (inlineType.writeByteOrdered()) out.writeObjectByteOrder(value, key.dataType());
        else out.writeObject(value, key.dataType());
    }
}
</code></pre>

<p>从代码我们可以看出，实际上都是对id进行的操作，所以如果知道了顶点的 id，给顶点添加边和属性，实际上不需要查询这个顶点，直接操作即可，所以这给我们导数据提供了一种思路，可以直接操作 id。</p>

<h2 id="writerelation-方法的参数怎么构造的">writeRelation 方法的参数怎么构造的</h2>

<p>从上面我们可以看出来 edgeSerializer.writeRelation 方法的参数是 (edge, type, pos, tx)，而 edge 来自于对 mutations 的处理，mutations 来自 add ,add 来自 addedRelations。</p>

<p>addedRelations 进行 add 操作的步骤在 StandardJanusGraph 的 connectRelation(InternalRelation r) 方法中。connectRelation 方法有两处调用 addEdge 和 addProperty。</p>

<p>addEdge 和 addProperty 的调用栈就比较多了。</p>

<h1 id="正向理清思路">正向理清思路</h1>

<h2 id="1-janus-官网介绍">1. janus 官网介绍</h2>

<p><a href="https://docs.janusgraph.org/latest/schema.html">https://docs.janusgraph.org/latest/schema.html</a></p>

<h3 id="edge-label">Edge Label</h3>

<p>Multiplicity</p>

<p>MULTI SIMPLE MANY2ONE ONE2MANY ONE2ONE 五种，每种的意义可以参考官网。默认的是 MULTI</p>

<h3 id="property-keys">Property Keys</h3>

<p>dataType(Class) 确定数据类型，Object.class 能够传入任何参数，但是不鼓励。</p>

<p>Property Key Cardinality</p>

<p>SINGLE: Allows at most one value per element for such key. In other words, the key→value mapping is unique for all elements in the graph. The property key birthDate is an example with SINGLE cardinality since each person has exactly one birth date.
LIST: Allows an arbitrary number of values per element for such key. In other words, the key is associated with a list of values allowing duplicate values. Assuming we model sensors as vertices in a graph, the property key sensorReading is an example with LIST cardinality to allow lots of (potentially duplicate) sensor readings to be recorded.
SET: Allows multiple values but no duplicate values per element for such key. In other words, the key is associated with a set of values. The property key name has SET cardinality if we want to capture all names of an individual (including nick name, maiden name, etc).</p>

<h3 id="relation-types">Relation Types</h3>

<p>Edge labels and property keys are jointly referred to as relation types ,must unique</p>

<h3 id="vertex-labels">Vertex Labels</h3>

<p>call makeVertexLabel(String).make()</p>

<h3 id="unidirected-edges">Unidirected Edges</h3>

<p>单向的边是只能在向外方向上遍历的边。单指向边具有较低的存储占用，但在它们支持的遍历类型中受到限制。单向的边在概念上类似于万维网中的超链接，在这个意义上，外顶点可以遍历边缘，但是顶点不知道它的存在。</p>

<h2 id="2-addproperty-和-addedge">2. addProperty 和 addEdge</h2>

<pre><code class="language-java">public JanusGraphVertexProperty addProperty(VertexProperty.Cardinality cardinality, JanusGraphVertex vertex, PropertyKey key, Object value) {
    if (key.cardinality().convert()!=cardinality &amp;&amp; cardinality!=VertexProperty.Cardinality.single)
        throw new SchemaViolationException(&quot;Key is defined for %s cardinality which conflicts with specified: %s&quot;,key.cardinality(),cardinality);
    verifyWriteAccess(vertex);
    Preconditions.checkArgument(!(key instanceof ImplicitKey),&quot;Cannot create a property of implicit type: %s&quot;,key.name());
    vertex = ((InternalVertex) vertex).it();
    Preconditions.checkNotNull(key);
    checkPropertyConstraintForVertexOrCreatePropertyConstraint(vertex, key);
    final Object normalizedValue = verifyAttribute(key, value);
    
    // 得到 Cardinality SINGLE LIST SET ，一般是 SINGLE
    Cardinality keyCardinality = key.cardinality();
    
    // 省略部分代码
    try {
          // 省略检查
          
        StandardVertexProperty prop = new StandardVertexProperty(IDManager.getTemporaryRelationID(temporaryIds.nextID()), key, (InternalVertex) vertex, normalizedValue, ElementLifeCycle.New);
        if (config.hasAssignIDsImmediately()) graph.assignID(prop);
        connectRelation(prop);
        return prop;
    } finally {
        uniqueLock.unlock();
    }

}

public JanusGraphEdge addEdge(JanusGraphVertex outVertex, JanusGraphVertex inVertex, EdgeLabel label) {
    verifyWriteAccess(outVertex, inVertex);
    outVertex = ((InternalVertex) outVertex).it();
    inVertex = ((InternalVertex) inVertex).it();
    Preconditions.checkNotNull(label);
    checkConnectionConstraintOrCreateConnectionConstraint(outVertex, inVertex, label);
    Multiplicity multiplicity = label.multiplicity();
    TransactionLock uniqueLock = getUniquenessLock(outVertex, (InternalRelationType) label,inVertex);
    uniqueLock.lock(LOCK_TIMEOUT);
    try {
     // 省略检查
        StandardEdge edge = new StandardEdge(IDManager.getTemporaryRelationID(temporaryIds.nextID()), label, (InternalVertex) outVertex, (InternalVertex) inVertex, ElementLifeCycle.New);
        if (config.hasAssignIDsImmediately()) graph.assignID(edge);
        connectRelation(edge);
        return edge;
    } finally {
        uniqueLock.unlock();
    }
}
</code></pre>

<p>其实这两个做的最主要的就两步： new StandardEdge new StandardVertexProperty  connectRelation(edge);</p>

<p>connectRelation 最主要的就是 addedRelations.add&reg;</p>

<p>最后在 commit 的时候，会 处理  addedRelations，代码逻辑在上面我们已经看过了。我们在简化一下：</p>

<pre><code class="language-java">for (InternalRelation add : Iterables.filter(addedRelations,filter)) {
    Preconditions.checkArgument(add.isNew());

    for (int pos = 0; pos &lt; add.getLen(); pos++) {
        InternalVertex vertex = add.getVertex(pos);
        if (pos == 0 || !add.isLoop()) {
            // 添加 mutations
            mutations.put(vertex.longId(), add);
        }
    }
}

// 
for (Long vertexId : mutations.keySet()) {

    final List&lt;InternalRelation&gt; edges = mutations.get(vertexId);
    final List&lt;Entry&gt; additions = new ArrayList&lt;&gt;(edges.size());
    final List&lt;Entry&gt; deletions = new ArrayList&lt;&gt;(Math.max(10, edges.size() / 10));
    
    for (final InternalRelation edge : edges) {
        final InternalRelationType baseType = (InternalRelationType) edge.getType();
        assert baseType.getBaseType()==null;

        for (InternalRelationType type : baseType.getRelationIndexes()) { // getRelationIndexes 这里是得到了 RelationTypeIndex 相关的 关系
            if (type.getStatus()== SchemaStatus.DISABLED) continue;
            for (int pos = 0; pos &lt; edge.getArity(); pos++) {
                if (!type.isUnidirected(Direction.BOTH) &amp;&amp; !type.isUnidirected(EdgeDirection.fromPosition(pos)))
                    continue; //Directionality is not covered
                if (edge.getVertex(pos).longId()==vertexId) {
                    StaticArrayEntry entry = edgeSerializer.writeRelation(edge, type, pos, tx);
                    if (edge.isRemoved()) {
                        deletions.add(entry);
                    } else {
                        Preconditions.checkArgument(edge.isNew());
                        int ttl = getTTL(edge);
                        if (ttl &gt; 0) {
                            entry.setMetaData(EntryMetaData.TTL, ttl);
                        }
                        additions.add(entry);
                    }
                }
            }
        }
    }

    StaticBuffer vertexKey = idManager.getKey(vertexId);
    mutator.mutateEdges(vertexKey, additions, deletions);
}
</code></pre>

<h2 id="mutateedges">mutateEdges</h2>

<p>会逐步调用
edgeStore.mutateEntries(key, additions, deletions, storeTx);
mutateEntries(StaticBuffer key, List<Entry> additions, List<Entry> deletions, StoreTransaction txh)
mutate</p>

<p>mutate 会将改变都记录到 mutations 中，在 flushInternal 的时候 mutations 会变换一下记录到 subMutations ，然后调用 persist(subMutations);
紧接着调用 manager.mutateMany(subMutations, tx); 最后重构成 cfmutation，通过 cassandra 的 CTConnection 保存到 cassandra 中。</p>

<p>这样看来，整个过程就清晰了。</p>

<h2 id="id-分配">id 分配</h2>

<p>StandardIDPool 进行 id 的分配，调用 graph.assignID(schemaVertex, BaseVertexLabel.DEFAULT_VERTEXLABEL) 等方法的时候，会调用。</p>

<pre><code class="language-java">assignID:455, StandardJanusGraph (org.janusgraph.graphdb.database)
assignID:153, VertexIDAssigner (org.janusgraph.graphdb.database.idassigner)
assignID:182, VertexIDAssigner (org.janusgraph.graphdb.database.idassigner)
assignID:308, VertexIDAssigner (org.janusgraph.graphdb.database.idassigner)
nextID:204, StandardIDPool (org.janusgraph.graphdb.database.idassigner)
nextBlock:173, StandardIDPool (org.janusgraph.graphdb.database.idassigner)
startIDBlockGetter:247, StandardIDPool (org.janusgraph.graphdb.database.idassigner)

call:288, StandardIDPool$IDBlockGetter (org.janusgraph.graphdb.database.idassigner)
getIDBlock:213, ConsistentKeyIDAuthority (org.janusgraph.diskstorage.idmanagement)
    getBlockApplication:373, ConsistentKeyIDAuthority (org.janusgraph.diskstorage.idmanagement)
idStore.mutate(partitionKey, Arrays.asList(StaticArrayEntry.of(finalTarget)), KeyColumnValueStore.NO_DELETIONS, txh);
</code></pre>

<p>这里涉及到了很多东西，而且是在两个线程中完成的，就不太方便处理了。</p>

<h3 id="vertexidassigner">VertexIDAssigner</h3>

<p>首先是 VertexIDAssigner 的创建：</p>

<pre><code class="language-java">public VertexIDAssigner(Configuration config, IDAuthority idAuthority, StoreFeatures idAuthFeatures) {
    Preconditions.checkNotNull(idAuthority);
    this.idAuthority = idAuthority;

    int partitionBits = NumberUtil.getPowerOf2(config.get(CLUSTER_MAX_PARTITIONS));
    idManager = new IDManager(partitionBits);
    Preconditions.checkArgument(idManager.getPartitionBound() &lt;= Integer.MAX_VALUE &amp;&amp; idManager.getPartitionBound()&gt;0);
    this.partitionIdBound = (int)idManager.getPartitionBound();
    hasLocalPartitions = idAuthFeatures.hasLocalKeyPartition();

    placementStrategy = Backend.getImplementationClass(config, config.get(PLACEMENT_STRATEGY),
            REGISTERED_PLACEMENT_STRATEGIES);
    placementStrategy.injectIDManager(idManager);
    log.debug(&quot;Partition IDs? [{}], Local Partitions? [{}]&quot;,true,hasLocalPartitions);

    long baseBlockSize = config.get(IDS_BLOCK_SIZE);
    idAuthority.setIDBlockSizer(new SimpleVertexIDBlockSizer(baseBlockSize));

    renewTimeoutMS = config.get(IDS_RENEW_TIMEOUT);
    renewBufferPercentage = config.get(IDS_RENEW_BUFFER_PERCENTAGE);

    idPools = new ConcurrentHashMap&lt;Integer, PartitionIDPool&gt;(partitionIdBound);
    schemaIdPool = new StandardIDPool(idAuthority, IDManager.SCHEMA_PARTITION, PoolType.SCHEMA.getIDNamespace(),
            IDManager.getSchemaCountBound(), renewTimeoutMS, renewBufferPercentage);
    partitionVertexIdPool = new StandardIDPool(idAuthority, IDManager.PARTITIONED_VERTEX_PARTITION, PoolType.PARTITIONED_VERTEX.getIDNamespace(),
            PoolType.PARTITIONED_VERTEX.getCountBound(idManager), renewTimeoutMS, renewBufferPercentage);
    setLocalPartitions(partitionBits);
}
</code></pre>

<p>里面主要有 idAuthority , idManager(partitionBits=5) partitionIdBound=32  placementStrategy idPools schemaIdPool partitionVertexIdPool .</p>

<h4 id="assignid">assignID</h4>

<p>id 有三个部分组成 [0 count suffix partitionId],count，最高位是0，然后是后缀。后缀在 IDManager 中有配置,partitionId 默认是5位.
第一部是 得到 partitionID ，分为很多种情况，例如 schema 为0，分区的为 -1，vertex 的为 placementStrategy 随机获得。例如8， Relation 通过 incident 获得。</p>

<p>然后才是 assignID
先得到 count ，得到过程是：
通过 partition 在 idPools 得到 PartitionIDPool，如果没有，新建 PartitionIDPool ，然后在每个 PartitionIDPool 中新建 3个 StandardIDPool ，分别对应 NORMAL_VERTEX, UNMODIFIABLE_VERTEX, RELATION;
在 PartitionIDPool 中得到现在的 element 所对应的 idPool，然后调用 count = idPool.nextID()  得到count ,nextID 会调用 currentBlock 得到 id。如果当前的 currentBlock 分配完了，重新申请一个 block</p>

<p>调用 getId 方法的时候，会有一个 uniqueIDBitWidth ，默认是 4位，然后还有一个 unique 数值是0，最后返回的是得到的count 左右4位，如果是1，就是16.
返回了 count，然后构造的 结果就是 00000 0 000010000000</p>

<h3 id="standardidpool">StandardIDPool</h3>

<p>构造传入了：idAuthority partition idNamespace idUpperBound renewBufferPercentage
还有一个 exec ，用来执行线程。
还有 currentBlock currentIndex renewBlockIndex 记录当前的状态。</p>

<p>###</p>

<p>我们从 assignID 开始看。分为两步：</p>

<p>partitionID = placementStrategy.getPartition(element);</p>

<h2 id="调试一次">调试一次</h2>

<p>接下来我们可以调试一次，通过调试过每一步，熟悉每一步的内容。</p>

<h1 id="bulk-loading">bulk loading</h1>

<p>接下来我们要做一个导数据的工具。我们有一堆给定好的书籍，然后我们能够将数据导入到 janus 中，我们需要结合 cassandra 和 hbase 自带的 bulk loading 工具。
首先我们需要得到所有的序列化的数据，实际上就是 edge 数据，而 index 的数据我们可以后续调用 reindex。</p>

<h2 id="vertex-导入">vertex 导入</h2>

<p>我们可以想象一下，导入边的流程，首先要有一个表格，并且这个表格要带有表头，然后下面的就是数据。表头包括字段名和数据类型，其中第一个是主键。例如有电话的数据，表头结构为：
phone:string,name:string,relation:integer</p>

<p>我们程序首先是验证数据，验证数据主要是重复性检验，格式检验。然后需要创建 schema。读取所有的表头，并创建好 schema。然后导入数据。</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">邓子明</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-07-09</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="https://github.com/dengziming/blogs/blob/master/images/wechat.jpg?raw=true">
        <span>Wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="https://github.com/dengziming/blogs/blob/master/images/alipay.jpg?raw=true">
        <span>Alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/janusgraph/">janusgraph</a>
          
          <a href="/tags/%E6%BA%90%E7%A0%81/">源码</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/titan/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%907-%E5%85%B3%E7%B3%BB%E5%AD%98%E5%82%A8/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">janusgraph源码分析7-关系存储</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/titan/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%908-%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8/">
            <span class="next-text nav-default">janusgraph源码分析8-索引存储</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
    

  

  

  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '2018-07-09 00:00:00 \x2b0000 UTC',
    title: 'janusgraph源码分析8-底层交互',
    link: decodeURI(location.href),
    desc: '反向分析 cassandra 写数据 API cassandra 的结构类似 bigtable ，数据实际上是多层嵌套的 map，第一个 key 是 rowkey，第二层key 是 columnFamily，第三层key',
    owner: 'dengziming',
    repo: 'https:\/\/github.com\/dengziming\/comment.oi.git',
    oauth: {
      client_id: '1eb2e794cac943b9af79',
      client_secret: 'a4f7d62a2a52b5c43e51c0c476a3b605029ac372'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>
  </article>
        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="zmdeng@aliyun.com" rel="me" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://twitter.com/dengziming2/" rel="me" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://www.facebook.com/deng.ziming.7" rel="me" class="iconfont icon-facebook" title="facebook"></a>
      <a href="https://www.linkedin.com/in/%E5%AD%90-%E9%82%93-72a924133/" rel="me" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="dengziming1993@gmail.com" rel="me" class="iconfont icon-google" title="google"></a>
      <a href="http://www.github.com/dengziming" rel="me" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://en.xianmin.org/hugo-theme-jane/" rel="me" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://en.xianmin.org/hugo-theme-jane/" rel="me" class="iconfont icon-goodreads" title="goodreads"></a>
  <a href="https://dengziming.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">邓子明</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>





</body>
</html>
