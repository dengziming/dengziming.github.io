<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title> - 数据分析师之旅</title>
  <link rel="alternate" hreflang="zh-cn" href="https://dengziming.github.io/" />

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="邓子明" />
  <meta name="description" content="EncodingIdMapper put 方法：
long eId = encode( inputId ); dataCache.set( nodeId, eId ); groupCache.set( nodeId, group.id() ); candidateHighestSetIndex.offer( nodeId );  dataCache.set( nodeId, eId );
DynamicLongArray.set(long index, long value ) at( index ).set( index, value ); 1. at {DynamicNumberArray&amp;lt;N extends NumberArray&amp;lt;N&amp;gt;&amp;gt; @Override public N at( long index ) { if ( index &amp;gt;= length() ) { synchronizedAddChunk( index ); // 扩容 new OffHeapLongArray( length, defaultValue, base ); } int chunkIndex = chunkIndex( index ); return chunks[chunkIndex]; } } at 方法先看情况给 chunks 扩容，实际上就是新建一个 OffHeapLongArray ，放到 chunks 数租，然后返回一个。实际上就是返回当前的顶点应该所在的 LongArray。 2." />

  <meta name="keywords" content="大数据, AI, 机器学习" />






<meta name="generator" content="Hugo 0.26" />


<link rel="canonical" href="https://dengziming.github.io/post/neo4j/neo4j%E5%AF%BC%E6%95%B0%E6%8D%AE%E4%B9%8Bid%E6%98%A0%E5%B0%84/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<link href="/dist/jane.min.css?v=2.7.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="" />
<meta property="og:description" content="EncodingIdMapper put 方法：
long eId = encode( inputId ); dataCache.set( nodeId, eId ); groupCache.set( nodeId, group.id() ); candidateHighestSetIndex.offer( nodeId );  dataCache.set( nodeId, eId );
DynamicLongArray.set(long index, long value ) at( index ).set( index, value ); 1. at {DynamicNumberArray&lt;N extends NumberArray&lt;N&gt;&gt; @Override public N at( long index ) { if ( index &gt;= length() ) { synchronizedAddChunk( index ); // 扩容 new OffHeapLongArray( length, defaultValue, base ); } int chunkIndex = chunkIndex( index ); return chunks[chunkIndex]; } } at 方法先看情况给 chunks 扩容，实际上就是新建一个 OffHeapLongArray ，放到 chunks 数租，然后返回一个。实际上就是返回当前的顶点应该所在的 LongArray。 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dengziming.github.io/post/neo4j/neo4j%E5%AF%BC%E6%95%B0%E6%8D%AE%E4%B9%8Bid%E6%98%A0%E5%B0%84/" />
















<meta itemprop="name" content="">
<meta itemprop="description" content="EncodingIdMapper put 方法：
long eId = encode( inputId ); dataCache.set( nodeId, eId ); groupCache.set( nodeId, group.id() ); candidateHighestSetIndex.offer( nodeId );  dataCache.set( nodeId, eId );
DynamicLongArray.set(long index, long value ) at( index ).set( index, value ); 1. at {DynamicNumberArray&lt;N extends NumberArray&lt;N&gt;&gt; @Override public N at( long index ) { if ( index &gt;= length() ) { synchronizedAddChunk( index ); // 扩容 new OffHeapLongArray( length, defaultValue, base ); } int chunkIndex = chunkIndex( index ); return chunks[chunkIndex]; } } at 方法先看情况给 chunks 扩容，实际上就是新建一个 OffHeapLongArray ，放到 chunks 数租，然后返回一个。实际上就是返回当前的顶点应该所在的 LongArray。 2.">



<meta itemprop="wordCount" content="2203">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content=""/>
<meta name="twitter:description" content="EncodingIdMapper put 方法：
long eId = encode( inputId ); dataCache.set( nodeId, eId ); groupCache.set( nodeId, group.id() ); candidateHighestSetIndex.offer( nodeId );  dataCache.set( nodeId, eId );
DynamicLongArray.set(long index, long value ) at( index ).set( index, value ); 1. at {DynamicNumberArray&lt;N extends NumberArray&lt;N&gt;&gt; @Override public N at( long index ) { if ( index &gt;= length() ) { synchronizedAddChunk( index ); // 扩容 new OffHeapLongArray( length, defaultValue, base ); } int chunkIndex = chunkIndex( index ); return chunks[chunkIndex]; } } at 方法先看情况给 chunks 扩容，实际上就是新建一个 OffHeapLongArray ，放到 chunks 数租，然后返回一个。实际上就是返回当前的顶点应该所在的 LongArray。 2."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Dengziming</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">列表</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a><a href="https://gohugo.io">
        <li class="mobile-menu-item">站外链接</li>
      </a>
  </ul>
</nav>

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">Dengziming</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        
        <a class="menu-item-link" href="/">Home</a>
        
      </li><li class="menu-item">
        
        <a class="menu-item-link" href="/post/">列表</a>
        
      </li><li class="menu-item">
        
        <a class="menu-item-link" href="/tags/">标签</a>
        
      </li><li class="menu-item">
        
        <a class="menu-item-link" href="/categories/">分类</a>
        
      </li><li class="menu-item">
        
        <a class="menu-item-link" href="/about/">About</a>
        
      </li><li class="menu-item">
        
        <a class="menu-item-link" href="https://gohugo.io" target="_blank">
          站外链接
          <i class="iconfont icon-new-window"></i>
        </a>
        
      </li>
  </ul>
</nav>
  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title"></h1>

      <div class="post-meta">
        <span class="post-time"> 0001-01-01 </span>
        
        <span class="more-meta"> 2203 words </span>
        <span class="more-meta"> 11 min read </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  
  <div class="post-toc-content">
    
  </div>
</div>

    
    <div class="post-content">
      <p>EncodingIdMapper
put 方法：</p>

<pre><code class="language-java">
long eId = encode( inputId );

dataCache.set( nodeId, eId );

groupCache.set( nodeId, group.id() );

candidateHighestSetIndex.offer( nodeId );
</code></pre>

<p>dataCache.set( nodeId, eId );</p>

<pre><code class="language-java">DynamicLongArray.set(long index, long value )

at( index ).set( index, value );

1. at
{DynamicNumberArray&lt;N extends NumberArray&lt;N&gt;&gt;

    @Override
    public N at( long index )
    {
        if ( index &gt;= length() )
        {
            synchronizedAddChunk( index );
            // 扩容 new OffHeapLongArray( length, defaultValue, base );
        }

        int chunkIndex = chunkIndex( index );
        return chunks[chunkIndex];
    }
}

at 方法先看情况给 chunks 扩容，实际上就是新建一个 OffHeapLongArray ，放到 chunks 数租，然后返回一个。实际上就是返回当前的顶点应该所在的 LongArray。

2. set
{OffHeapLongArray
    
    @Override
    public void set( long index, long value )
    {
        UnsafeUtil.putLong( addressOf( index ), value );
    }
    
    addressOf(index)
    {
        index = rebase( index ); // index - base;
        if ( index &lt; 0 || index &gt;= length )
        {
            throw new ArrayIndexOutOfBoundsException( &quot;Requested index &quot; + index + &quot;, but length is &quot; + length );
        }
        // 
        return address + (index &lt;&lt; shift); // 在当前位置左移三位，也就是乘以8，因为保存一个 long 要 8位？
    }
    putLong:
    unsafe.putLong( address, value );
    
}


</code></pre>

<p>dataCache 的set逻辑比较清楚了，dataCache 是一个 DynamicLongArray ，里面有一个 chunks = OffHeapLongArray[] ,
每个 OffHeapLongArray 长度是一百万，数据增多了就新建 OffHeapLongArray。
然后通过 Unsafe 的方法赋值，因为 ne4j 的 id 是连续的，所以直接移动八位就是下一个数据的存储地址。然后 putLong 放进去。
这里我们其实有一些疑问，现在其实是将顶点的值 value 放到了它的 id 对应的位置上，我们要查一个 id 对应的值只需要找到对应地址即可，
我们需要查询一个 value 对应的 id 还是没法查，所以我们接下来要研究一下怎么查。</p>

<p>看 get 方法，看名字就知道这是一个二分查找，二分查找有个前提是数据是排好序的，然后不断得到中间的值和现有的值对比。</p>

<pre><code class="language-java">private long binarySearch( Object inputId, int groupId )
{
    long low = 0;
    long high = highestSetIndex;
    // 得到加密后的 value 
    long x = encode( inputId );
    // 这个方法得到 x 的基数
    int rIndex = radixOf( x );
    
    // for 循环中，rIndex 和 sortBuckets 二维数组的 第一行的值作比较，如果满足了条件，就取对应的第二行和下一个第二行的值作为 low 和 high。
    // 根据这个逻辑我们大概能判断出来，sortBuckets 中放的是分位点，第一行放的是 rIndex 分位点，第二行放的是 index 的分位点，而且 index 对应的值一个个是排好序的，不然没法二分查找。
    // 
    for ( int k = 0; k &lt; sortBuckets.length; k++ )
    {
        if ( rIndex &lt;= sortBuckets[k][0] )//bucketRange[k] &gt; rIndex )
        {
            low = sortBuckets[k][1];
            high = (k == sortBuckets.length - 1) ? highestSetIndex : sortBuckets[k + 1][1];
            break;
        }
    }

    long returnVal = binarySearch( x, inputId, low, high, groupId );
    if ( returnVal == ID_NOT_FOUND )
    {
        low = 0;
        high = highestSetIndex;
        returnVal = binarySearch( x, inputId, low, high, groupId );
    }
    return returnVal;
}


private long binarySearch( long x, Object inputId, long low, long high, int groupId )
{
    while ( low &lt;= high )
    {
        // 中值点 low 和 high 都是 index
        long mid = low + (high - low) / 2;//(low + high) / 2;
        
        // trackerCache 能根据值 index 得到 真正的 index ？
        
        long dataIndex = trackerCache.get( mid );
        if ( dataIndex == ID_NOT_FOUND )
        {
            return ID_NOT_FOUND;
        }
        // 查找 value，dataCache 是我们上面放数据的 DynamicLongArray ，根据 index 能查到 值。
        long midValue = dataCache.get( dataIndex );
        switch ( unsignedDifference( clearCollision( midValue ), x ) )
        {
        case EQ:
            // We found the value we were looking for. Question now is whether or not it's the only
            // of its kind. Not all values that there are duplicates of are considered collisions,
            // read more in detectAndMarkCollisions(). So regardless we need to check previous/next
            // if they are the same value.
            boolean leftEq = mid &gt; 0 &amp;&amp; unsignedCompare( x, dataValue( mid - 1 ), CompareType.EQ );
            boolean rightEq = mid &lt; highestSetIndex &amp;&amp; unsignedCompare( x, dataValue( mid + 1 ), CompareType.EQ );
            if ( leftEq || rightEq )
            {   // OK so there are actually multiple equal data values here, we need to go through them all
                // to be sure we find the correct one.
                return findFromEIdRange( leftEq ? mid - 1 : mid, rightEq ? mid + 1 : mid, midValue, inputId, x, groupId );
            }
            // This is the only value here, let's do a simple comparison with correct group id and return
            return groupOf( dataIndex ) == groupId ? dataIndex : ID_NOT_FOUND;
        case LT:
            low = mid + 1;
            break;
        default:
            high = mid - 1;
            break;
        }
    }
    return ID_NOT_FOUND;
}
</code></pre>

<p>整个查询到这里感觉很乱，我们先理一下，我们要在 dataCache 中查找某个 x，首先通过 radixOf 方法得到一个 rIndex，再通过 rIndex 在 sortBuckets 数组中找到 high 和 low，
在第二个方法中，high 和 low，可以通过 trackerCache 得到 dataIndex，然后 dataCache.get( dataIndex ) 得到了 value。</p>

<p>其实熟悉排序算法的话，第二个方法并不难明白。在有的排序算法中，排序算法涉及到交换，而我们保存在内存的数据进行交换是很麻烦的，所以我们再加一个数组记录数据下标，每次不交换数据只交换下标。
这种方式本身不复杂，只是多了一层，可能比较绕，我们用一个例子梳理一下。
假如：要排序的三个数 data[2,4,1], 我们先记下 index[0,1,2]，然后进行排序，以冒泡排序为例：
    1. 比较 data[index[0]], data[index[1]],无需交换，然后比较 data[index[1]], data[index[2]],发现 4比1大，然后交换index为[0,2,1],
    2. 然后继续比较 data[index[0]], data[index[1]],发现2大于1，交换 index 为 [2,0,1] ，
    3. 得到的排序结果是 data[2,3,1], index[2,0,1] 。
如果是别的排序方法类似，例如快速排序，我们先记下 data[2,5,1,3,0],index[0,1,2,3,4]，首先所有的数据和 data[index[0]] 比较，得到index[2,4,0,1,3]，然后继续得到 index[4,2,0,3,1].</p>

<p>排序好了以后，我们需要进行查找操作，而二分查找也需要先根据index找到对应位置的数据，
例如上面5个数据我要查找 3 ,首先 left=0,right=4, mid =2，而 data[index[2]]=2,小于3，所以 left=2+1,mid=3 ，data[index[3]]=3,查找到了对应的索引是 3,</p>

<p>所以我们可以猜想这里也是这个道理 dataCahce 排序的时候并没有交换数据二是通过 trackerCache 交换了对应的索引。
而要查找 dataCahce 的数据，首先在得到 mid ，这个 mid 实际上是数据按照大小的排名，然后从 trackerCache 得到排名为 mid 的索引，
然后调用 dataCache 得到排名为 mid 的数据，和已有的数据进行比较。</p>

<p>我们看看 trackerCache 注释：</p>

<pre><code class="language-java">// Ordering information about values in dataCache; the ordering of values in dataCache remains unchanged.
// in prepare() this array is populated and changed along with how dataCache items &quot;move around&quot; so that
// they end up sorted. Again, dataCache remains unchanged, only the ordering information is kept here.
// Each index in trackerCache points to a dataCache index, where the value in dataCache contains the
// encoded input id, used to match against the input id that is looked up during binary search.
</code></pre>

<p>注释说的很清楚，trackerCache 是 dataCache 的排序信息，dataCache 的数据是不变的， prepare() 执行的时候 trackerCache 生成并且随着 dataCache 排序而改变，记录 dataCache 的顺序，
trackerCache 的每个索引指向 dataCache 的一个位置，where 放置了 加密的 inputId ，在 binarysearch 用来匹配输入的 inputId。那重点就是 prepare() 方法。</p>

<p>trackerCache 的问题解决了，sortBuckets 大概是什么意思？dataCache 的长度可能有几十亿，即便是二分查找，也要很久，所以我们是否可以大概确定一个上下限呢？其实就是桶排序，或者基数排序。
例如：data[1,2,3,4,5,6,7,8,9,10] 我们要查找 9的位置，是否可以先把它分成 [1,2,3,4,5],[6,7,8,9,10] 两个，记下他们的上下限 [0，5],[1,10]。来一个数据先缩小一下它的范围，再进行二分查找？</p>

<p>而对于存在内存中的数据，需要进行基数排序，然后进行快速排序是有一定要求的。</p>

<p>我们看一下需要看一下 encode 和 radixOf 的代码，</p>

<p>encode:Encodes String into a long with very small chance of collision</p>

<pre><code class="language-java">@Override
public long encode( Object s )
{
    int[] val = encodeInt( (String) s ); 
    return (long) val[0] &lt;&lt; 32 | val[1] &amp; UPPER_INT_MASK; // 连接 val[0] 和 val[1]
}

private int[] encodeInt( String s )
{
    // 将 String 变成bytes
    int inputLength = s.length();
    byte[] bytes = new byte[inputLength];
    for ( int i = 0; i &lt; inputLength; i++ )
    {
        bytes[i] = (byte) ((s.charAt( i )) % 127);
    }
    
    // 调用 remap, 将 bytes[i] 转化为 reMap[bytes[i]]
    reMap( bytes, inputLength );
    
    // encode 长度小于 7 的 简单编码
    if ( inputLength &lt;= encodingThreshold )
    {
        
        return simplestCode( bytes, inputLength );
    }
    int[] codes = new int[numCodes];
    for ( int i = 0; i &lt; numCodes; )
    {
        codes[i] = getCode( bytes, inputLength, 1 );
        codes[i + 1] = getCode( bytes, inputLength, inputLength - 1 );
        i += 2;
    }
    int carryOver = lengthEncoder( inputLength ) &lt;&lt; 1;
    int temp = 0;
    for ( int i = 0; i &lt; numCodes; i++ )
    {
        temp = codes[i] &amp; FOURTH_BYTE;
        codes[i] = codes[i] &gt;&gt;&gt; 8 | carryOver &lt;&lt; 24;
        carryOver = temp;
    }
    return codes;
}
private int lengthEncoder( int length )
{
    if ( length &lt; 32 )
    {
        return length;
    }
    else if ( length &lt;= 96 )
    {
        return length &gt;&gt; 1;
    }
    else if ( length &lt;= 324 )
    {
        return length &gt;&gt; 2;
    }
    else if ( length &lt;= 580 )
    {
        return length &gt;&gt; 3;
    }
    else if ( length &lt;= 836 )
    {
        return length &gt;&gt; 4;
    }
    else
    {
        return 127;
    }
}

// reMap 方法就是给 bytes 做一个一一隐射，将 bytes[i] 转化为 reMap[bytes[i]]，0&lt;=bytes[i]&lt;=255
private void reMap( byte[] bytes, int inputLength )
{
    for ( int i = 0; i &lt; inputLength; i++ )
    {
        if ( reMap[bytes[i]] == -1 )
        {
            synchronized ( this )
            {
                if ( reMap[bytes[i]] == -1 )
                {
                    reMap[bytes[i]] = (byte) (numChars++ % 256);
                }
            }
        }
        bytes[i] = reMap[bytes[i]];
    }
}

// 
private int[] simplestCode( byte[] bytes, int inputLength )
{
    int[] codes = new int[]{0, 0};
    codes[0] = max( inputLength, 1 ) &lt;&lt; 25; 长度左移 25位，inputLength_0000000000
    codes[1] = 0;
    for ( int i = 0; i &lt; 3 &amp;&amp; i &lt; inputLength; i++ )
    {
        codes[0] = codes[0] | bytes[i] &lt;&lt; ((2 - i) * 8);  bytes[i] 左移 16,8,0 位后和已有的 codes[0] 取或，
    }
    for ( int i = 3; i &lt; 7 &amp;&amp; i &lt; inputLength; i++ )
    {
        codes[1] = codes[1] | (bytes[i]) &lt;&lt; ((6 - i) * 8);bytes[i] 左移 16,8,0 位后和已有的 codes[1]取或，
    }
    return codes;
}

private int getCode( byte[] bytes, int inputLength, int order )
{
    long code = 0;
    int size = inputLength;
    for ( int i = 0; i &lt; size; i++ )
    {
        //code += (((long)bytes[(i*order) % size]) &lt;&lt; (i % 7)*8);
        long val = bytes[(i * order) % size];
        for ( int k = 1; k &lt;= i; k++ )
        {
            long prev = val;
            val = (val &lt;&lt; 4) + prev;//% Integer.MAX_VALUE;
        }
        code += val;
    }
    return (int) code;
}
</code></pre>

<p>encode 太复杂了，我们知道是尽量保证不重复的long即可，编码的前 8位 是长度编码，后面的是数据编码，中间留了一个0.</p>

<p>radixOf : Calculates and keeps radix counts. Uses a {@link RadixCalculator} to calculate an integer radix value from a long value.</p>

<pre><code class="language-java">protected static final int RADIX_BITS = 24; // 24 位
protected static final long LENGTH_BITS = 0xFE000000_00000000L; // 1111_1110_00000000000000000 (56个0)
protected static final int LENGTH_MASK = (int) (LENGTH_BITS &gt;&gt;&gt; (64 - RADIX_BITS)); // 右移40位 还剩24位  1111_111_00000000000000 (17 个零)
protected static final int HASHCODE_MASK = (int) (0x00FFFF00_00000000L &gt;&gt;&gt; (64 - RADIX_BITS)); 右移40位 还剩24位  0000_0000_1111_1111_1111_1111
/**
  * Radix optimized for strings encoded into long by {@link StringEncoder}.
  */
 public static class String extends RadixCalculator
 {
     @Override
     public int radixOf( long value )
     {
         int index = (int) (value &gt;&gt;&gt; (64 - RADIX_BITS));  RADIX_BITS = 24 右移40位 还剩高位24个位，
         index = ((index &amp; LENGTH_MASK) &gt;&gt;&gt; 1) | (index &amp; HASHCODE_MASK);  //  (FE00 &amp; index) | (00FFFF &amp; index) 其实就是取 index 的前7位和后16位。也就是去掉第17位
         return index; // 整个逻辑就是先去掉低40位变成24位 index，然后去掉第17位。
     }
 }
</code></pre>

<p>编码最后去掉第17位是因为第17位是 0 没有意义。</p>

<p>这里大概知道用了什么原理，接下来我们 prepare 方法，看看 sort 的过程。我们大概已经知道使用了 基数排序和快速排序。</p>

<p>ParallelSort 的 run 方法，首先是 sortRadix</p>

<pre><code class="language-java">// 实际上就是将数据按照 thread 数量分为几个桶，
private long[][] sortRadix() throws InterruptedException
{
    long[][] rangeParams = new long[threads][2];
    int[] bucketRange = new int[threads];
    // 初始化的工作，初始化应该主要就是得到几个分桶。
    Workers&lt;TrackerInitializer&gt; initializers = new Workers&lt;&gt;( &quot;TrackerInitializer&quot; );
    // sortBuckets 保存分桶信息，一共两行，第一行是捅的 index ，第二行是数据的 index
    sortBuckets = new long[threads][2];
    
    long dataSize = highestSetIndex + 1;
    long bucketSize = dataSize / threads;
    long count = 0;
    long fullCount = 0;
    progress.started( &quot;SPLIT&quot; );
    //遍历所有数据 radixIndex， 每个基数对应的数据的个数，基数 = 先去掉低40位变成24位 index，然后第17位变为0。
    for ( int i = 0, threadIndex = 0; i &lt; radixIndexCount.length &amp;&amp; threadIndex &lt; threads; i++ )
    {
        // 已找到的的数据 ，也就是基数 &gt; bucketSize
        if ( (count + radixIndexCount[i]) &gt; bucketSize )
        {
            // 现在要根据线程数将整个基数分成几个桶， bucketRange 保存分位点位置，
            bucketRange[threadIndex] = count == 0 ? i : i - 1; 
            // rangeParams 的第一行是截至目前数据总量
            rangeParams[threadIndex][0] = fullCount;
            if ( count != 0 )
            {
                // rangeParams 的第二行是当前数据量
                rangeParams[threadIndex][1] = count;
                fullCount += count;
                progress.add( count );
                count = radixIndexCount[i];
            }
            else
            {
                rangeParams[threadIndex][1] = radixIndexCount[i];
                fullCount += radixIndexCount[i];
                progress.add( radixIndexCount[i] );
            }
            initializers.start( new TrackerInitializer( threadIndex, rangeParams[threadIndex],
                    threadIndex &gt; 0 ? bucketRange[threadIndex - 1] : -1, bucketRange[threadIndex],
                    sortBuckets[threadIndex] ) );
            threadIndex++;
        }
        else
        {
            count += radixIndexCount[i];
        }
        if ( threadIndex == threads - 1 || i == radixIndexCount.length - 1 )
        {
            bucketRange[threadIndex] = radixIndexCount.length;
            rangeParams[threadIndex][0] = fullCount;
            rangeParams[threadIndex][1] = dataSize - fullCount;
            initializers.start( new TrackerInitializer( threadIndex, rangeParams[threadIndex],
                    threadIndex &gt; 0 ? bucketRange[threadIndex - 1] : -1, bucketRange[threadIndex],
                    sortBuckets[threadIndex] ) );
            break;
        }
    }
    progress.done();

    // In the loop above where we split up radixes into buckets, we start one thread per bucket whose
    // job is to populate trackerCache and sortBuckets where each thread will not touch the same
    // data indexes as any other thread. Here we wait for them all to finish.
    Throwable error = initializers.await();
    long[] bucketIndex = new long[threads];
    int i = 0;
    for ( TrackerInitializer initializer : initializers )
    {
        bucketIndex[i++] = initializer.bucketIndex;
    }
    if ( error != null )
    {
        throw new AssertionError( error.getMessage() + &quot;\n&quot; + dumpBuckets( rangeParams, bucketRange, bucketIndex ),
                error );
    }
    return rangeParams;
}

</code></pre>

<p>TrackerInitializer 的 start 启动一个线程，我们看看 run 方法。</p>

<pre><code class="language-java">public void run()
{
    for ( long i = 0; i &lt;= highestSetIndex; i++ )
    {
        // 计算基数，也就是在 整个基数桶 中的位置
        int rIndex = radixCalculator.radixOf( comparator.dataValue( dataCache.get( i ) ) );
        
        // 看看这个数是否属于这个桶。
        if ( rIndex &gt; lowRadixRange &amp;&amp; rIndex &lt;= highRadixRange )
        {
            // rangeParams 保存了当前线程在桶中的上下限。
            long trackerIndex = rangeParams[0] + bucketIndex++;
            assert tracker.get( trackerIndex ) == -1 :
                    &quot;Overlapping buckets i:&quot; + i + &quot;, k:&quot; + threadIndex + &quot;, index:&quot; + trackerIndex;
            
            // 这个设置到 tracker 中。每个 trackerIndex 对应一个 i，每个 i 也对应一个 trackerIndex。
            tracker.set( trackerIndex, i );
            
            // 如果到达了上界。
            if ( bucketIndex == rangeParams[1] )
            {
                result[0] = highRadixRange;
                result[1] = rangeParams[0];
            }
        }
    }
}
</code></pre>

<p>TrackerInitializer 的 run 方法作用就是在 tracker 设置 trackerIndex 和 i 的对应关系， trackerIndex 是 i 的基数在桶中的位置 + 当前 bucket 的 Index bucketIndex 是递增的。</p>

<p>然后我们看 SortWorker 排序。关键逻辑在 partition 中。</p>

<pre><code class="language-java">private long partition( long leftIndex, long rightIndex, long pivotIndex )
{
    // left 和 right ，right 为倒数第二个
    long li = leftIndex;
    long ri = rightIndex - 2;
    long pi = pivotIndex;
    long pivot = clearCollision( dataCache.get( tracker.get( pi ) ) );
    
    // save pivot in last index，先把 pivot 放到最后
    tracker.swap( pi, rightIndex - 1 );
    long left = clearCollision( dataCache.get( tracker.get( li ) ) );
    long right = clearCollision( dataCache.get( tracker.get( ri ) ) );
    while ( li &lt; ri )
    {
        // 左边和 pivot 比较
        if ( comparator.lt( left, pivot ) )
        {   
            // this value is on the correct side of the pivot, moving on。 左边的比 pivot 小，不用管，直接看下一个。
            left = clearCollision( dataCache.get( tracker.get( ++li ) ) );
        }
        else if ( comparator.ge( right, pivot ) )
        {   // this value is on the correct side of the pivot, moving on 。右边的比 pivot 大，不用管，下一个
            right = clearCollision( dataCache.get( tracker.get( --ri ) ) );
        }
        else
        {   // this value is on the wrong side of the pivot, swapping， 右边的比 pivot 小，左边的比 pivot 大，交换一下。
            tracker.swap( li, ri );
            long temp = left;
            left = right;
            right = temp;
        }
    }
    long partingIndex = ri;
    if ( comparator.lt( right, pivot ) )
    {
        partingIndex++;
    }
    // restore pivot
    tracker.swap( rightIndex - 1, partingIndex );
    return partingIndex;
}
</code></pre>

<p>这是快速排序的实现方法。
截至目前，其实还有一点没解决，就是 tracker ，tracker 中存放了 trackerIndex 和 index 的键值对，里面是怎么存储的其实值得我们研究。</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">邓子明</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">0001-01-01</span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>

    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="https://github.com/dengziming/blogs/blob/master/images/wechat.jpg?raw=true">
        <span>Wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="https://github.com/dengziming/blogs/blob/master/images/alipay.jpg?raw=true">
        <span>Alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/oop/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">面向对象经验</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">
            <span class="next-text nav-default"></span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
    

  

  

  <div id="comments-gitment"></div>
  <link rel="stylesheet" href="/lib/gitment/gitment-0.0.3.min.css">
    <script src="/lib/gitment/gitment-0.0.3.min.js"></script>
  <script type="text/javascript">
  const gitment = new Gitment({
    id: '0001-01-01 00:00:00 \x2b0000 UTC',
    title: '',
    link: decodeURI(location.href),
    desc: 'EncodingIdMapper put 方法：\nlong eId = encode( inputId ); dataCache.set( nodeId, eId ); groupCache.set( nodeId, group.id() ); candidateHighestSetIndex.offer( nodeId );  dataCache.set( nodeId, eId );\nDynamicLongArray.set(long index, long value ) at( index ).set( index, value ); 1. at {DynamicNumberArray\x26lt;N extends NumberArray\x26lt;N\x26gt;\x26gt; @Override public N at( long index ) { if ( index \x26gt;= length() ) { synchronizedAddChunk( index ); \/\/ 扩容 new OffHeapLongArray( length, defaultValue, base ); } int chunkIndex = chunkIndex( index ); return chunks[chunkIndex]; } } at 方法先看情况给 chunks 扩容，实际上就是新建一个 OffHeapLongArray ，放到 chunks 数租，然后返回一个。实际上就是返回当前的顶点应该所在的 LongArray。 2.',
    owner: 'dengziming',
    repo: 'https:\/\/github.com\/dengziming\/comment.oi.git',
    oauth: {
      client_id: '1eb2e794cac943b9af79',
      client_secret: 'a4f7d62a2a52b5c43e51c0c476a3b605029ac372'
    }
  })
  gitment.render('comments-gitment')
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>
  </article>
        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="zmdeng@aliyun.com" rel="me" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://twitter.com/dengziming2/" rel="me" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://www.facebook.com/deng.ziming.7" rel="me" class="iconfont icon-facebook" title="facebook"></a>
      <a href="https://www.linkedin.com/in/%E5%AD%90-%E9%82%93-72a924133/" rel="me" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="dengziming1993@gmail.com" rel="me" class="iconfont icon-google" title="google"></a>
      <a href="http://www.github.com/dengziming" rel="me" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" rel="me" class="iconfont icon-instagram" title="instagram"></a>
      <a href="http://en.xianmin.org/hugo-theme-jane/" rel="me" class="iconfont icon-gitlab" title="gitlab"></a>
      <a href="http://en.xianmin.org/hugo-theme-jane/" rel="me" class="iconfont icon-goodreads" title="goodreads"></a>
  <a href="https://dengziming.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2019
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">邓子明</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/jane.min.js?v=2.7.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML'></script>





</body>
</html>
