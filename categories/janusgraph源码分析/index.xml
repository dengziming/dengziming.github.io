<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Janusgraph源码分析 on 数据分析师之旅</title>
    <link>https://dengziming.github.io/categories/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
    <description>Recent content in Janusgraph源码分析 on 数据分析师之旅</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 09 Jul 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://dengziming.github.io/categories/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>janusgraph源码分析7-关系存储</title>
      <link>https://dengziming.github.io/post/titan/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%907-%E5%85%B3%E7%B3%BB%E5%AD%98%E5%82%A8/</link>
      <pubDate>Mon, 09 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/titan/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%907-%E5%85%B3%E7%B3%BB%E5%AD%98%E5%82%A8/</guid>
      
        <description>

&lt;h1 id=&#34;基础类&#34;&gt;基础类&lt;/h1&gt;

&lt;h2 id=&#34;internalrelation-和-internalrelationtype&#34;&gt;InternalRelation 和 InternalRelationType&lt;/h2&gt;

&lt;p&gt;有关类型体系很复杂，可以使用 IDEA 的显示继承体系功能，查看类图。类图比较大，不太好看。大概描述一下：
主要是 JanusGraphElement 作为顶级类，接下来还有一个 InternalElement 作为顶级的 Internal 类。
JanusGraphElement 继承的类主要分为 JanusGraphRelation,JanusGraphVertex 两个分支，前者又分为 JanusGraphVertexProperty, JanusGraphEdge 。
InternalElement 的继承类主要分为 InternalRelation ,InternalVertex 两个分支，前者又分为 JanusGraphVertexProperty, JanusGraphEdge 。
其中 Internal 开头类总是有一个 JanusGraph 开头的类作为父类。例如 InternalRelation 继承自 JanusGraphRelation。&lt;/p&gt;

&lt;p&gt;JanusGraphVertex 比较特殊，他除了有 InternalVertex 子类以外，还有 VertexLabel 和 RelationType 两个子类。
同理 InternalVertex 的继承体系下，除了真正的实体以外，还有一个 JanusGraphSchemaVertex ，他有 VertexLabelVertex, RelationTypeVertex 两个子类，
RelationTypeVertex 又有 EdgeLabelVertex 和 PropertyKeyVertex 两个子类。还有 BaseLabel BaseKey BaseVerteLabel 等子类。&lt;/p&gt;

&lt;p&gt;这里就需要提到我们之前说的，janus 的 schema 也是以顶点的形式保存的，顶级类就是 JanusGraphSchemaVertex ，有 VertexLabelVertex, EdgeLabelVertex 和 PropertyKeyVertex 三个实现。
他们分别代表了 VertexLabel EdgeLabel PropertyKey 的 Vertex，同时我们想想，这些 Vertex 也是 janus 的元素 也是有属性的，我们岂不是还要新建三个类，保存他们的 Property Label 等？
然后他们的 Label 也是有属性的，这样下去就子子孙孙无穷尽也。所以才有了上面的 BaseLabel BaseKey BaseVerteLabel 作为终极的 Vertex。&lt;/p&gt;

&lt;p&gt;然后我们看一下 InternalRelation 和 InternalRelationType 的关系，InternalRelation 代表的就是一种关系，有 JanusGraphEdge 和 JanusGraphVertexProperty 两种，&lt;/p&gt;

&lt;p&gt;例如一个用户的性别是女，也就是给一个顶点添加一个性别 &lt;code&gt;女&lt;/code&gt; 的属性：
首先有两个顶点, a: InternalVertex (JanusGraphVertex)， 性别则是一个 b: PropertyKey (InternalRelationType) 也是一个 Vertex，
而 &lt;code&gt;女&lt;/code&gt; 则是 property 的值，实际上就是在这两个不同类型的 Vertex 之间建立一条连接。再加上一个 value 这三个组合在一起就是一个 JanusGraphVertexProperty 。&lt;/p&gt;

&lt;p&gt;再例如我们要给一个顶点的 VertexLabel 是 User：
首先有一个用户顶点，a: InternalVertex (JanusGraphVertex)，然后 User 也是一个建好的 schema，也就是顶点： VertexLabelVertex 。然后给他们之间建立一条关系，这个关系也是一个顶点 BaseLabel.VertexLabelEdge。&lt;/p&gt;

&lt;p&gt;在比如给两个用户之间添加一个 Friend 的关系。
首先有两个顶点就是用户，然后新建一个 StandardEdge，然后 这两个顶点分别和这个 StandardEdge 建立一个 EdgeLabel 为 Friend 的关系。&lt;/p&gt;

&lt;p&gt;到这里我们大概明白，其实添加 Property 就是和 和一个 PropertyKey 建立一条边，添加 Edge 就是和一个 vertex 建立一条边，添加 VertexLabel 就是和一个 VertexLabel 建立一条边。&lt;/p&gt;

&lt;p&gt;InternalRelation 就是添加的边，可以序列化存储起来，也可以读出来反序列化成 InternalRelation。 InternalRelationType 就是类型，类型也是一个顶点， 而 PropertyKey 这种类型对应的属性都是 Base开头的。&lt;/p&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&#34;relationcache&#34;&gt;RelationCache&lt;/h2&gt;

&lt;h2 id=&#34;staticarrayentry&#34;&gt;StaticArrayEntry&lt;/h2&gt;

&lt;p&gt;类似 java.nio 的 ByteBuffer。&lt;/p&gt;

&lt;h1 id=&#34;edgeserializer&#34;&gt;EdgeSerializer&lt;/h1&gt;

&lt;h2 id=&#34;writerelation&#34;&gt;writeRelation&lt;/h2&gt;

&lt;p&gt;EdgeSerializer 类主要用来写 edgestore 库，这个库序列化方式相对比较简单，但代码还是比较多。&lt;/p&gt;

&lt;p&gt;从代码调用开始看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for (Long vertexId : mutations.keySet()) {
       Preconditions.checkArgument(vertexId &amp;gt; 0, &amp;quot;Vertex has no id: %s&amp;quot;, vertexId);
       final List&amp;lt;InternalRelation&amp;gt; edges = mutations.get(vertexId);
       final List&amp;lt;Entry&amp;gt; additions = new ArrayList&amp;lt;&amp;gt;(edges.size());
       final List&amp;lt;Entry&amp;gt; deletions = new ArrayList&amp;lt;&amp;gt;(Math.max(10, edges.size() / 10));
       for (final InternalRelation edge : edges) {
           final InternalRelationType baseType = (InternalRelationType) edge.getType();
           assert baseType.getBaseType()==null;

           for (InternalRelationType type : baseType.getRelationIndexes()) {
               if (type.getStatus()== SchemaStatus.DISABLED) continue;
               for (int pos = 0; pos &amp;lt; edge.getArity(); pos++) {
                   if (!type.isUnidirected(Direction.BOTH) &amp;amp;&amp;amp; !type.isUnidirected(EdgeDirection.fromPosition(pos)))
                       continue; //Directionality is not covered
                   if (edge.getVertex(pos).longId()==vertexId) {
                       StaticArrayEntry entry = edgeSerializer.writeRelation(edge, type, pos, tx);
                       if (edge.isRemoved()) {
                           deletions.add(entry);
                       } else {
                           Preconditions.checkArgument(edge.isNew());
                           int ttl = getTTL(edge);
                           if (ttl &amp;gt; 0) {
                               entry.setMetaData(EntryMetaData.TTL, ttl);
                           }
                           additions.add(entry);
                       }
                   }
               }
           }
       }

       StaticBuffer vertexKey = idManager.getKey(vertexId);
       mutator.mutateEdges(vertexKey, additions, deletions);
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是java类 StandardJanusGraph 写数据 的代码。可以看出写数据之前是需要调用 StaticArrayEntry entry = edgeSerializer.writeRelation(edge, type, pos, tx);
所以接下来我么的任务就是看看这个方法，我们先看看这几个参数的意义：&lt;/p&gt;

&lt;p&gt;InternalRelation relation, 代表一条关系，可以是 edge，也可以是 Property。
如果是edge，edge的两个顶点都会保存这条边，如果是 Property，只会有节点保存，PropertyKey 不会保存。&lt;/p&gt;

&lt;p&gt;InternalRelationType type,  可以是 Property 和 Edge&lt;/p&gt;

&lt;p&gt;int position, 通过调用部分代码，可以看出表示顶点在这个关系中的位置。例如 v1 -[e1]-&amp;gt; v2, 对于e1来讲，v1的pos是0，v2的pos是1。
TypeInspector tx 用来检测类型.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public StaticArrayEntry writeRelation(InternalRelation relation, 
										InternalRelationType type, 
										int position,
										TypeInspector tx) 
										
{
    // 判断类型
    assert type==relation.getType() || (type.getBaseType() != null
            &amp;amp;&amp;amp; type.getBaseType().equals(relation.getType()));
    // 得到方向，可以是 只有 OUT 和 IN 两种结果
    Direction dir = EdgeDirection.fromPosition(position);
    
    // isUnidirected 方法是判断是不是这个方向的。
    Preconditions.checkArgument(type.isUnidirected(Direction.BOTH) || type.isUnidirected(dir));
    
    // 得到 type 的id，注意 JanusGraph 中的schema 也是以顶点的形式存储，也有 id。
    long typeId = type.longId();
    
    // 得到 PROPERTY_DIR 或者 EDGE_OUT_DIR 或者 EDGE_IN_DIR
    DirectionID dirID = getDirID(dir, relation.isProperty() ? RelationCategory.PROPERTY : RelationCategory.EDGE);

    // 得到一个输出，实际就是 byte 数组
    DataOutput out = serializer.getDataOutput(DEFAULT_CAPACITY);
    
    // 保存 key 和 value 的临界点
    int valuePosition;
    
    // 这里调用方法写入 typeId dirID isInvisibleType ，详细内容我们后面看 TODO
    IDHandler.writeRelationType(out, typeId, dirID, type.isInvisibleType());
    
    // multiplicity 代表多元性
    Multiplicity multiplicity = type.multiplicity();

    long[] sortKey = type.getSortKey();
    // 多对多关系不允许有排序的key
    assert !multiplicity.isConstrained() || sortKey.length==0: type.name();
    
    int keyStartPos = out.getPosition();
    if (!multiplicity.isConstrained()) { // isConstrained 代表是否有限制。SINGLE 和 SET 有限制，LIST 无限制。
        // 写排序key ，这个方法后面讨论 TODO
        writeInlineTypes(sortKey, relation, out, tx, InlineType.KEY);
    }
    int keyEndPos = out.getPosition();

    long relationId = relation.longId();

    //How multiplicity is handled for edges and properties is slightly different
    if (relation.isEdge()) {  // 如果是边关系
        // 得到另一个顶点的id
        long otherVertexId = relation.getVertex((position + 1) % 2).longId();
        if (multiplicity.isConstrained()) { // 非多对多
            if (multiplicity.isUnique(dir)) { // 只有一个这种类型的边。例如每个 Person只有一个父亲节点。
                valuePosition = out.getPosition(); // 得到 position
                // 写出另一个顶点的id
                VariableLong.writePositive(out, otherVertexId);
            } else { // 可能有多个关系，例如一个Person可能有多个 儿子节点
                
                // 这时候从后往前写，这个方法后面讨论  TODO 
                VariableLong.writePositiveBackward(out, otherVertexId);
                valuePosition = out.getPosition();
            }
            // 然后写出 关系的 relationId
            VariableLong.writePositive(out, relationId);
        } else {// 多对多，我们的数据绝大部分都是这种情况
            //从后往前写 vertex 和 relationId。得到position
            VariableLong.writePositiveBackward(out, otherVertexId);
            VariableLong.writePositiveBackward(out, relationId);
            valuePosition = out.getPosition();
        }

/**
总结上面
SortKey是一种特殊的属性，JanusGraph允许在定义Edge Label时指定其中的一个或多个属性为Sort Key。
对于边的Sort Key属性，JanusGraph在存储时会将其存储在Relation Type ID的后面,其他所有字段的前面。
通过这种方式，可以保证一个节点的多条同一个类型的边，会按Sort Key属性排序存储。这对于一个节点有大量边时，对查询性能提升有帮助。

MULTIPLICITY为MULTI时的存储结构： 从后往前写 otherVertexId 和 relationId。其余放在 value 里面

MULTIPLICITY非MULTI且此方向存在多条边时的存储结构：从后往前写 otherVertexId，relationId 和其余放在 value里面

MULTIPLICITY非MULTI且此方向仅有一条边时的存储结构： 不记录relationId，otherVertexId 放在value 里面
*/

    } else { // 如果是属性关系，得到属性的 key 和 value
        assert relation.isProperty();
        Preconditions.checkArgument(relation.isProperty());
        Object value = ((JanusGraphVertexProperty) relation).value();
        Preconditions.checkNotNull(value);
        PropertyKey key = (PropertyKey) type;
        assert key.dataType().isInstance(value);

        // 没有限制，不是 LIST 类型
        if (multiplicity.isConstrained()) {
            if (multiplicity.isUnique(dir)) { //Cardinality=SINGLE
                // property 放在 value 中
                valuePosition = out.getPosition();
                writePropertyValue(out,key,value);
            } else { //Cardinality=SET
                // property 放在 key 中
                writePropertyValue(out,key,value);
                valuePosition = out.getPosition();
            }
            // 写出 relationId
            VariableLong.writePositive(out, relationId);
        } else {
            assert multiplicity.getCardinality()== Cardinality.LIST;
            // 在key中反向写出 relationId, property 放在 value 中
            VariableLong.writePositiveBackward(out, relationId);
            valuePosition = out.getPosition();
            writePropertyValue(out,key,value);
        }
    }

/** 总结上面

Cardinality为SINGLE时的存储结构

列名只存储Property Key的ID及方向。具体的Property Value值以及Property ID(relationId)，都存放在Cell的Value中。
另外，如果该Property还有额外的 Remaining properties，也会放在Value中。Remaining properties一般不使用，仅在一些特殊场景下，用于为该Property记录更多的附加信息(比如存储元数据Edge Labe的定义等)。

PropertyKeyID 及方向整个结构的详细结构在后文中描述；占用一个或多个字段，具体格式在后文描述;及采用相同的格式，具体格式在后文描述。

Candinality为LIST时的存储结构

各个部分与Cardinality为SINGLE时的结构相似，区别在于属性的ID被放在了列名中，而不是放在Value中。

Candinality为SET存储结构

各个部分与Cardinality为SINGLE时的结构相似，区别在于属性的值被放在了列名中，而不是放在Value中。

*** /


    //Write signature 
    // 得到 relationType 所有的 signature 的 PropertyKeyid，写到 value 中
    long[] signature = type.getSignature();
    writeInlineTypes(signature, relation, out, tx, InlineType.SIGNATURE);

    //Write remaining properties
    // sortKey 和 signature 是已经写过，所以排除掉
    LongSet writtenTypes = new LongHashSet(sortKey.length + signature.length);
    if (sortKey.length &amp;gt; 0 || signature.length &amp;gt; 0) {
        for (long id : sortKey) writtenTypes.add(id);
        for (long id : signature) writtenTypes.add(id);
    }
    LongArrayList remainingTypes = new LongArrayList(8);
    for (PropertyKey t : relation.getPropertyKeysDirect()) {
        if (!(t instanceof ImplicitKey) &amp;amp;&amp;amp; !writtenTypes.contains(t.longId())) {
            remainingTypes.add(t.longId());
        }
    }
    //Sort types before writing to ensure that value is always written the same way
    long[] remaining = remainingTypes.toArray();
    Arrays.sort(remaining);
    for (long tid : remaining) {
        // 剩下的 value 写到值部分。
        PropertyKey t = tx.getExistingPropertyKey(tid);
        writeInline(out, t, relation.getValueDirect(t), InlineType.NORMAL);
    }
    assert valuePosition&amp;gt;0;

    // 返回，返回的时候需要注意根据 type.getSortOrder() 的结果进行判断，如果 DESC 需要将 key 部分反过来
    return new StaticArrayEntry(type.getSortOrder() == Order.DESC ?
                                out.getStaticBufferFlipBytes(keyStartPos, keyEndPos) :
                                out.getStaticBuffer(), valuePosition);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到这里我们基本了解了数据的存储结构，但是细节还是没了解。比如key具体多少位，每一位是啥。接下来我们需要稍微了解一下每次写的时候对应方法的细节。
我们只需要找有变量 out 的代码部分。&lt;/p&gt;

&lt;p&gt;第一次是 &lt;code&gt;DataOutput out = serializer.getDataOutput(DEFAULT_CAPACITY)&lt;/code&gt;, 这个就是创建新的Buffer，然后是 IDHandler 写部分。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * The edge type is written as follows: [ Invisible &amp;amp;amp; System (2 bit) | Relation-Type-ID (1 bit) | Relation-Type-Count (variable) | Direction-ID (1 bit)]
 * Would only need 1 bit to store relation-type-id, but using two so we can upper bound.
 * 
 * 注释说明，edge格式： Invisible &amp;amp; System  2bit, Relation-Type-ID 1 bit, Relation-Type-Count 变化的,Direction-ID 一位。
 * 这里有个小疑问，Relation-Type-ID 也是一个 long 类型，1bit 应该没法表示。我们在代码中看
 *
 * @param out
 * @param relationTypeId
 * @param dirID
 */
public static void writeRelationType(WriteBuffer out, long relationTypeId, DirectionID dirID, boolean invisible) {
    
    // 断言判断
    assert relationTypeId &amp;gt; 0 &amp;amp;&amp;amp; (relationTypeId &amp;lt;&amp;lt; 1) &amp;gt; 0; //Check positive and no-overflow

    // 去掉 relationTypeId 的 padding，在后面补一位 dirID.getDirectionInt。
    long strippedId = (IDManager.stripEntireRelationTypePadding(relationTypeId) &amp;lt;&amp;lt; 1) + dirID.getDirectionInt();
    {
    // 这个方法就是将 id 的 Padding 部分 去掉。
    public static long stripEntireRelationTypePadding(long id) {
        Preconditions.checkArgument(isProperRelationType(id));
        return VertexIDType.UserEdgeLabel.removePadding(id);
        {
            VertexIDType.UserEdgeLabel.removePadding(id){
                id &amp;gt;&amp;gt;&amp;gt; offset();// 这个 offset() 代表 id 的padding 长度，NormalVertex 是 3，EdgeLabel 是5，UserEdgeLabel 是6
            }
        }
    }
    }
    
    //
    VariableLong.writePositiveWithPrefix(out, strippedId, dirID.getPrefix(invisible, IDManager.isSystemRelationTypeId(relationTypeId)), PREFIX_BIT_LEN);
    {
    // IDManager.isSystemRelationTypeId(relationTypeId)) 判断是否是系统关系
    // getPrefix 方法如下，其实就是得到了 上面所说的数据，
    	private int getPrefix(boolean invisible, boolean systemType) {
    	    assert !systemType || invisible; // systemType implies invisible
    	    return ((systemType?0:invisible?2:1)&amp;lt;&amp;lt;1) + getRelationType();
    	}
    
    // 整个方法就是写下 prefix strippedId 。
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整个方法大概就清楚了，然后是 writeInlineTypes 和 writeInline ，writePropertyValue ，和上面的方法类似。
然后是 VariableLong.writePositiveBackward(out, otherVertexId); 和 VariableLong.writePositive(out, otherVertexId);&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void writePositive(WriteBuffer out, final long value) {
    assert value &amp;gt;= 0;
    writeUnsigned(out, value);
    
    	/** writeUnsigned 方法 */
    	{
    	private static void writeUnsigned(WriteBuffer out, final long value) {
    	    writeUnsigned(out, unsignedBlockBitLength(value), value);
    	    
    	    /** unsignedBlockBitLength 最终是 block 的数量 * 7 */
    	    {
    	    return unsignedNumBlocks(value)*7;
    	    	/** unsignedNumBlocks 求 block 数量 */
    	    	{
    	    	     return numVariableBlocks(unsignedBitLength(value));
    	    	     {
    	    	     // 得到数据去掉所有0 的位数，如果是0有1位。也就是无符号位数
    	    	     unsignedBitLength(value){
    	    	         return (value == 0) ? 1 : Long.SIZE - Long.numberOfLeadingZeros(value);
    	    	     }
    	    	     /** 这个方法返回 位数－1 除以 7 再加一，
    	    	     简单理解 ,就是第一个bit一个 block，剩下每7bit 一个 block
    	    	     实际上是除以七进一。
    	    	      */
    	    	     numVariableBlocks{
    	    	         return (numBits - 1) / 7 + 1;
    	    	     }
    	    	     }
    	    	}
    	    }
    	    
    	    /** writeUnsigned 方法 */
    	    {
    		private static void writeUnsigned(WriteBuffer out, int offset, final long value) {
        		assert offset % 7 == 0;
        		while (offset &amp;gt; 0) { // offset 就是上面求的 block 数量 * 7
        		    offset -= 7; // 一次写 7 位。
        		    
        		    byte b = (byte) ((value &amp;gt;&amp;gt;&amp;gt; offset) &amp;amp; BIT_MASK); // 左移 offset 与 01111111 进行 `逻辑与` 操作。
        		    if (offset == 0) {
        		        b = (byte) (b | STOP_MASK);  // 如果是最后一位，再与 -128(111111...1110000000) 进行或操作,这个操作的结果会得到一个类似补码的数据
        		    }
        		    out.putByte(b);
    		    }
    		}
    	    }
    	}
    }
}
/**
综上所述, 整个写 long 的方法，首先是计算数据的 block 数，每 7 位一个block。
写出的时候，每次写一个 byte(8bit)，其中一个block 7bit，再加一个占位符(0)。最后再与 -128(111111...1110000000) 进行或操作，
例如 72 会变成 -56， 满足 72 - (-56) = 128，这应该是补码还是反码记不清了。
*/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是  VariableLong.writePositiveBackward(out, otherVertexId)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
/**
 * The format used is this:
 * - The first bit indicates whether this is the first block (reading backwards, this would be the stop criterion)
 * - In the first byte, the 3 bits after the first bit indicate the number of bytes written minus 3 (since 3 is
 * the minimum number of bytes written. So, if the 3 bits are 010 = 2 =&amp;gt; 5 bytes written. The value is aligned to
 * the left to ensure that this encoding is byte order preserving.
 *
 *  根据注释，第一 bit 表示是否是第一个 block （往后读需要一个停止标识），紧接着代表数据的位数。
 * 
 * @param out
 * @param value
 */
private static void writeUnsignedBackward(WriteBuffer out, final long value) {
    
    int numBytes = unsignedBackwardLength(value);
    /** unsignedBackwardLength 这个类似上面，得到最少的 bytes 数量。可以看出至少有3 bytes。*/
    {
        int bitLength = unsignedBitLength(value); // 这个上面已经看过。
        assert bitLength &amp;gt; 0 &amp;amp;&amp;amp; bitLength &amp;lt;= 64;
        return Math.max(3, 1 + (bitLength &amp;lt;= 4 ? 0 : (1 + (bitLength - 5) / 7)));
    }
    int prefixLen = numBytes - 3;
    assert prefixLen &amp;gt;= 0 &amp;amp;&amp;amp; prefixLen &amp;lt; 8; //Consumes 3 bits
    //Prepare first byte
    byte b = (byte)((prefixLen &amp;lt;&amp;lt; 4) | 0x80); //stop marker (first bit) and length
    for (int i = numBytes - 1; i &amp;gt;= 0; i--) {
        b = (byte)(b | (0x7F &amp;amp; (value &amp;gt;&amp;gt;&amp;gt; (i * 7)))); // 左移 i*7 位，和 0x7F 进行逻辑与，实际上就是取七位。
        out.putByte(b);
        b = 0;
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的对比我们看出 writePositiveBackward 和 writePositive 的差别在于 writePositiveBackward 把停止标识放在了开头，writePositive 放在结尾。&lt;/p&gt;

&lt;p&gt;看完序列化的代码我们可以大概知道存储的格式，我们整理一下。序列化的步骤在 writeRelation 中，首先写出Relation 的方向、可见性、schemaId，然后如果有sortKey写出sortKey的值，
然后判断是Edge 还是Property，根据他们的 multiplicity 处理有所不同。详情上面已经有了。最后还要写出 signature 和剩下的属性。&lt;/p&gt;

&lt;h2 id=&#34;readrelation&#34;&gt;readRelation&lt;/h2&gt;

&lt;p&gt;和 writeRelation 对应的是 readRelation，相关调用如下，主要是 readRelation 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Returns the list of adjacent vertex ids for this query. By reading those ids
 * from the entries directly (without creating objects) we get much better performance.
 *
 * @return
 */
public VertexList vertexIds() {
    LongArrayList list = new LongArrayList();
    long previousId = 0;
    for (Long id : Iterables.transform(this,new Function&amp;lt;Entry, Long&amp;gt;() {
        @Nullable
        @Override
        public Long apply(@Nullable Entry entry) {
            return edgeSerializer.readRelation(entry,true,tx).getOtherVertexId();
        }
    })) {
        list.add(id);
        if (id&amp;gt;=previousId &amp;amp;&amp;amp; previousId&amp;gt;=0) previousId=id;
        else previousId=-1;
    }
    return new VertexLongList(tx,list,previousId&amp;gt;=0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入方法发现核心就是一个 parseRelation 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
@Override
public RelationCache parseRelation(Entry data, boolean excludeProperties, TypeInspector tx) {
    ReadBuffer in = data.asReadBuffer();

    LongObjectHashMap properties = excludeProperties ? null : new LongObjectHashMap(4);
    
    // 第一步，读取关系类型。就是上面的写进去的 三位prefix+typeId ，包括方向，类型，可见性
    RelationTypeParse typeAndDir = IDHandler.readRelationType(in);

    long typeId = typeAndDir.typeId;
    Direction dir = typeAndDir.dirID.getDirection();

   // 根据id 查询对应的类型
    RelationType relationType = tx.getExistingRelationType(typeId);
    InternalRelationType def = (InternalRelationType) relationType;
    Multiplicity multiplicity = def.multiplicity();
    long[] keySignature = def.getSortKey();

    long relationId;
    Object other;
    int startKeyPos = in.getPosition();
    int endKeyPos = 0;
    
    // 这里和前面写的对应， 分别读取
    if (relationType.isEdgeLabel()) {
        long otherVertexId;
        if (multiplicity.isConstrained()) {
            if (multiplicity.isUnique(dir)) { 
                otherVertexId = VariableLong.readPositive(in);
            } else {
                in.movePositionTo(data.getValuePosition());
                otherVertexId = VariableLong.readPositiveBackward(in);
                in.movePositionTo(data.getValuePosition());
            }
            relationId = VariableLong.readPositive(in);
        } else {
            in.movePositionTo(data.getValuePosition());

            relationId = VariableLong.readPositiveBackward(in);
            otherVertexId = VariableLong.readPositiveBackward(in);
            endKeyPos = in.getPosition();
            in.movePositionTo(data.getValuePosition());
        }
        other = otherVertexId;
    } else {
        assert relationType.isPropertyKey();
        PropertyKey key = (PropertyKey) relationType;

        if (multiplicity.isConstrained()) {
            other = readPropertyValue(in,key);
            relationId = VariableLong.readPositive(in);
        } else {
            in.movePositionTo(data.getValuePosition());
            relationId = VariableLong.readPositiveBackward(in);
            endKeyPos = in.getPosition();
            in.movePositionTo(data.getValuePosition());
            other = readPropertyValue(in,key);
        }
        Preconditions.checkState(other!=null,
            &amp;quot;Encountered error in deserializer [null value returned]. Check serializer compatibility.&amp;quot;);
    }
    assert other!=null;

    // 
    if (!excludeProperties &amp;amp;&amp;amp; !multiplicity.isConstrained() &amp;amp;&amp;amp; keySignature.length&amp;gt;0) {
        int currentPos = in.getPosition();
        //Read sort key which only exists if type is not unique in this direction
        assert endKeyPos&amp;gt;startKeyPos;
        int keyLength = endKeyPos-startKeyPos; //after reading the ids, we are on the last byte of the key
        in.movePositionTo(startKeyPos);
        ReadBuffer inKey = in;
        if (def.getSortOrder()== Order.DESC) inKey = in.subrange(keyLength,true);
        readInlineTypes(keySignature, properties, inKey, tx, InlineType.KEY);
        in.movePositionTo(currentPos);
    }

    if (!excludeProperties) {
        //read value signature
        readInlineTypes(def.getSignature(), properties, in, tx, InlineType.SIGNATURE);

        //Third: read rest
        while (in.hasRemaining()) {
            PropertyKey type = tx.getExistingPropertyKey(IDHandler.readInlineRelationType(in));
            Object propertyValue = readInline(in, type, InlineType.NORMAL);
            assert propertyValue != null;
            properties.put(type.longId(), propertyValue);
        }

        if (data.hasMetaData()) {
            for (Map.Entry&amp;lt;EntryMetaData,Object&amp;gt; metas : data.getMetaData().entrySet()) {
                ImplicitKey key = ImplicitKey.MetaData2ImplicitKey.get(metas.getKey());
                if (key!=null) {
                    assert metas.getValue()!=null;
                    properties.put(key.longId(),metas.getValue());
                }
            }
        }
    }

    return new RelationCache(dir, typeId, relationId, other, properties);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看出，如果你熟悉上面的readRelation，就是 反过来读一遍。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>janusgraph源码分析8-底层交互</title>
      <link>https://dengziming.github.io/post/titan/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%909-%E8%B4%A1%E7%8C%AE%E5%AF%BC%E6%95%B0%E6%8D%AE%E6%BA%90%E7%A0%81/</link>
      <pubDate>Mon, 09 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/titan/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%909-%E8%B4%A1%E7%8C%AE%E5%AF%BC%E6%95%B0%E6%8D%AE%E6%BA%90%E7%A0%81/</guid>
      
        <description>

&lt;h1 id=&#34;反向分析&#34;&gt;反向分析&lt;/h1&gt;

&lt;h2 id=&#34;cassandra-写数据-api&#34;&gt;cassandra 写数据 API&lt;/h2&gt;

&lt;p&gt;cassandra 的结构类似 bigtable ，数据实际上是多层嵌套的 map，第一个 key 是 rowkey，第二层key 是 columnFamily，第三层key 是 column，第四层(也可以忽略) 是 timestamp，然后是 value。&lt;/p&gt;

&lt;p&gt;写数据的 API 如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt; CTConnection conn = null;
 try {
     conn = pool.borrowObject(keySpaceName);
     Cassandra.Client client = conn.getClient();
     if (atomicBatch) {
         client.atomic_batch_mutate(batch, consistency);
     } else {
         client.batch_mutate(batch, consistency);
     }
 } catch (Exception ex) {
     throw CassandraThriftKeyColumnValueStore.convertException(ex);
 } finally {
     pool.returnObjectUnsafe(keySpaceName, conn);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 batch 就是一个多层嵌套的map。&lt;code&gt;final Map&amp;lt;ByteBuffer, Map&amp;lt;String, List&amp;lt;org.apache.cassandra.thrift.Mutation&amp;gt;&amp;gt;&amp;gt; batch = new HashMap&amp;lt;&amp;gt;(size);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这里看起来只有两层，第一层的 ByteBuffer 当然是 rowKey，第二层是 String 是 columnFamily。而 &lt;code&gt;List&amp;lt;org.apache.cassandra.thrift.Mutation&amp;gt;&lt;/code&gt; 很明显就是添加或者删除的 key:value。&lt;/p&gt;

&lt;h2 id=&#34;写入-cassandra-的数据格式&#34;&gt;写入 cassandra 的数据格式&lt;/h2&gt;

&lt;p&gt;上面是写 cassandra 的 API，而最终调用这段代码的位置在 &lt;code&gt;CassandraThriftStoreManager.mutateMany(Map&amp;lt;String, Map&amp;lt;StaticBuffer, KCVMutation&amp;gt;&amp;gt; mutations, StoreTransaction txh)&lt;/code&gt; 方法。&lt;/p&gt;

&lt;p&gt;我们需要了解的就是  &lt;code&gt;Map&amp;lt;String, Map&amp;lt;StaticBuffer, KCVMutation&amp;gt;&amp;gt; mutations&lt;/code&gt; 和 &lt;code&gt;Map&amp;lt;ByteBuffer, Map&amp;lt;String, List&amp;lt;org.apache.cassandra.thrift.Mutation&amp;gt;&amp;gt;&amp;gt; batch&lt;/code&gt; 的对应关系。&lt;/p&gt;

&lt;p&gt;从代码可以看出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final Map&amp;lt;ByteBuffer, Map&amp;lt;String, List&amp;lt;org.apache.cassandra.thrift.Mutation&amp;gt;&amp;gt;&amp;gt; batch = new HashMap&amp;lt;&amp;gt;(size);

for (final Map.Entry&amp;lt;String, Map&amp;lt;StaticBuffer, KCVMutation&amp;gt;&amp;gt; keyMutation : mutations.entrySet()) {
    
    // mutations 的 key 是 columnFamily
    final String columnFamily = keyMutation.getKey(); 
    
    for (final Map.Entry&amp;lt;StaticBuffer, KCVMutation&amp;gt; mutEntry : keyMutation.getValue().entrySet()) {
        
        // mutations 的第二层 key 是 rowKey
        ByteBuffer keyBB = mutEntry.getKey().asByteBuffer();

        // Get or create the single Cassandra Mutation object responsible for this key
        // Most mutations only modify the edgeStore and indexStore
        
        final Map&amp;lt;String, List&amp;lt;org.apache.cassandra.thrift.Mutation&amp;gt;&amp;gt; cfmutation
            = batch.computeIfAbsent(keyBB, k -&amp;gt; new HashMap&amp;lt;&amp;gt;(3));

        final KCVMutation mutation = mutEntry.getValue();
        final List&amp;lt;org.apache.cassandra.thrift.Mutation&amp;gt; thriftMutation = new ArrayList&amp;lt;&amp;gt;(mutations.size());
        
        // 省略删除的代码。
        
        if (mutation.hasAdditions()) {
            
            for (final Entry ent : mutation.getAdditions()) {
                final ColumnOrSuperColumn columnOrSuperColumn = new ColumnOrSuperColumn();
                
                // mutations 的第三层 key 是 column
                final Column column = new Column(ent.getColumnAs(StaticBuffer.BB_FACTORY));
                // mutations 的 value 是 value
                column.setValue(ent.getValueAs(StaticBuffer.BB_FACTORY));

                column.setTimestamp(commitTime.getAdditionTime(times));

                final Integer ttl = (Integer) ent.getMetaData().get(EntryMetaData.TTL);
                if (null != ttl &amp;amp;&amp;amp; ttl &amp;gt; 0) {
                    column.setTtl(ttl);
                }

                columnOrSuperColumn.setColumn(column);
                org.apache.cassandra.thrift.Mutation m = new org.apache.cassandra.thrift.Mutation();
                m.setColumn_or_supercolumn(columnOrSuperColumn);
                thriftMutation.add(m);
            }
        }

        cfmutation.put(columnFamily, thriftMutation);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看出 mutateMany 方法的参数和写到 cassandra 的结果不是完全一致，主要是 rowkey 和 columnFamily 的位置是反的。&lt;/p&gt;

&lt;h2 id=&#34;传入-mutatemany-的数据&#34;&gt;传入 mutateMany 的数据&lt;/h2&gt;

&lt;p&gt;通过调试可以看出，调用 mutateMany 的地方主要是 &lt;code&gt;CacheTransation.persist&lt;/code&gt; ,而调用 persist 的就是 flushInternal 方法。相应代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 成员变量： Map&amp;lt;KCVSCache, Map&amp;lt;StaticBuffer, KCVEntryMutation&amp;gt;&amp;gt; mutations

// 新建Map，这个 map 就是上面 mutateMany 的参数，key 分别是 columnFamily 和 rowKey ，
final Map&amp;lt;String, Map&amp;lt;StaticBuffer, KCVMutation&amp;gt;&amp;gt; subMutations = new HashMap&amp;lt;&amp;gt;(mutations.size());

int numSubMutations = 0;
// 遍历 mutations
for (Map.Entry&amp;lt;KCVSCache,Map&amp;lt;StaticBuffer, KCVEntryMutation&amp;gt;&amp;gt; storeMutations : mutations.entrySet()) {
    final Map&amp;lt;StaticBuffer, KCVMutation&amp;gt; sub = new HashMap&amp;lt;&amp;gt;();
    
    // KCVSCache 的 getKey().getName() 就是 columnFamily
    subMutations.put(storeMutations.getKey().getName(),sub);
   
    // mutations 的 value
    for (Map.Entry&amp;lt;StaticBuffer,KCVEntryMutation&amp;gt; mutationsForKey : storeMutations.getValue().entrySet()) {
        if (mutationsForKey.getValue().isEmpty()) continue;
        
        // 将 mutationsForKey 放进去，这个 convert 做了啥没有具体研究，可能只是一个适配。
        sub.put(mutationsForKey.getKey(), convert(mutationsForKey.getValue()));
        numSubMutations+=mutationsForKey.getValue().getTotalMutations();
        if (numSubMutations&amp;gt;= persistChunkSize) {
            numSubMutations = persist(subMutations);
            sub.clear();
            subMutations.put(storeMutations.getKey().getName(),sub);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mutations-的构造&#34;&gt;mutations 的构造&lt;/h2&gt;

&lt;p&gt;上面我们看出了，其实基本上没复杂处理，接下来我们看看 mutations 数据哪里来的。&lt;/p&gt;

&lt;p&gt;对于 mutations 的修改操作，来自于 mutate 方法，代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 传入的是 store（包含了columnFamily） key（rowKey） additions 和 deletions
void mutate(KCVSCache store, StaticBuffer key, List&amp;lt;Entry&amp;gt; additions, List&amp;lt;Entry&amp;gt; deletions) throws BackendException {
    Preconditions.checkNotNull(store);
    if (additions.isEmpty() &amp;amp;&amp;amp; deletions.isEmpty()) return;
    
    // 构造 KCVEntryMutation
    KCVEntryMutation m = new KCVEntryMutation(additions, deletions);
    
    // 这几步就是简单的合并所以的 additions 和 deletions
    final Map&amp;lt;StaticBuffer, KCVEntryMutation&amp;gt; storeMutation = mutations.computeIfAbsent(store, k -&amp;gt; new HashMap&amp;lt;&amp;gt;());
    KCVEntryMutation existingM = storeMutation.get(key);
    
    if (existingM != null) {
        existingM.merge(m);
    } else {
        storeMutation.put(key, m);
    }

    numMutations += m.getTotalMutations();

    if (batchLoading &amp;amp;&amp;amp; numMutations &amp;gt;= persistChunkSize) {
        flushInternal();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mutate-方法参数来源&#34;&gt;mutate 方法参数来源&lt;/h2&gt;

&lt;p&gt;mutate 方法传入的是 store（包含了columnFamily） key（rowKey） additions 和 deletions，这几个参数哪里来的呢？ KCVSCache 的 mutateEntries，
mutateEdges 调用时机呢？ edgeStore.mutateEntries(key, additions, deletions, storeTx); indexStore.mutateEntries(key, additions, deletions, storeTx);
我们先以 edgeStore 为例，在 StandardJanusGraph 的 prepareCommit 方法中，调用了 mutator.mutateEdges(vertexKey, additions, deletions);
代码如下，我们删掉了部分代码，包括 索引和数据删除。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ListMultimap&amp;lt;Long, InternalRelation&amp;gt; mutations = ArrayListMultimap.create();
ListMultimap&amp;lt;InternalVertex, InternalRelation&amp;gt; mutatedProperties = ArrayListMultimap.create();
List&amp;lt;IndexSerializer.IndexUpdate&amp;gt; indexUpdates = Lists.newArrayList();


//2) Collect added edges and their index updates and acquire edge locks
// add 是 InternalRelation ，包括 VertexProperty 和 Edge，前面分析过，VertexProperty 实际上就是顶点和一个 schema 的订单建一条边，Edge 就是两个顶点建一条边。
for (InternalRelation add : Iterables.filter(addedRelations,filter)) {
    Preconditions.checkArgument(add.isNew());
    
    // getLen 返回这个 Relation 的长度，如果是 VertexProperty 是1，Edge 是需要根据方向进行判断
    for (int pos = 0; pos &amp;lt; add.getLen(); pos++) {
        // 得到对应的 vertex 
        InternalVertex vertex = add.getVertex(pos);
        if (pos == 0 || !add.isLoop()) {
        
            // mutatedProperties 的 key: InternalVertex,value:InternalRelation,mutatedProperties 是用于更新索引的，在我们这里实际上没什么用。
            if (add.isProperty()) mutatedProperties.put(vertex,add);
            // mutations 的 key ： vertexId, value ： InternalRelation
            mutations.put(vertex.longId(), add);
        }
        if (!vertex.isNew() &amp;amp;&amp;amp; acquireLock(add,pos,acquireLocks)) {
            Entry entry = edgeSerializer.writeRelation(add, pos, tx);
            mutator.acquireEdgeLock(idManager.getKey(vertex.longId()), entry.getColumn());
        }
    }
}


//5) Add relation mutations
for (Long vertexId : mutations.keySet()) {
    Preconditions.checkArgument(vertexId &amp;gt; 0, &amp;quot;Vertex has no id: %s&amp;quot;, vertexId);
    final List&amp;lt;InternalRelation&amp;gt; edges = mutations.get(vertexId);
    final List&amp;lt;Entry&amp;gt; additions = new ArrayList&amp;lt;&amp;gt;(edges.size());
    final List&amp;lt;Entry&amp;gt; deletions = new ArrayList&amp;lt;&amp;gt;(Math.max(10, edges.size() / 10));
    for (final InternalRelation edge : edges) {
        // 得到 InternalRelationType ，分为 PropertyKey 和 EdgeLabel 两类
        final InternalRelationType baseType = (InternalRelationType) edge.getType();
        assert baseType.getBaseType()==null;

        for (InternalRelationType type : baseType.getRelationIndexes()) { 
            if (type.getStatus()== SchemaStatus.DISABLED) continue;
            // getArity 和 getLen 不一样，
            for (int pos = 0; pos &amp;lt; edge.getArity(); pos++) {
                if (!type.isUnidirected(Direction.BOTH) &amp;amp;&amp;amp; !type.isUnidirected(EdgeDirection.fromPosition(pos)))
                    continue; //Directionality is not covered
                
                // 如果是起始顶点
                if (edge.getVertex(pos).longId()==vertexId) {
                
                    // 根据 edge type pos tx 得到应该序列化的 StaticArrayEntry
                    StaticArrayEntry entry = edgeSerializer.writeRelation(edge, type, pos, tx);
                    if (edge.isRemoved()) {
                        deletions.add(entry);
                    } else {
                        Preconditions.checkArgument(edge.isNew());
                        int ttl = getTTL(edge);
                        if (ttl &amp;gt; 0) {
                            entry.setMetaData(EntryMetaData.TTL, ttl);
                        }
                        additions.add(entry);
                    }
                }
            }
        }
    }

    StaticBuffer vertexKey = idManager.getKey(vertexId);
    mutator.mutateEdges(vertexKey, additions, deletions);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;edgeserializer-writerelation-到底做了什么&#34;&gt;edgeSerializer.writeRelation 到底做了什么&lt;/h2&gt;

&lt;p&gt;我们现在就想知道，数据是怎么被序列化话 entry 的，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public StaticArrayEntry writeRelation(InternalRelation relation, InternalRelationType type, int position,
                                      TypeInspector tx) {
    assert type==relation.getType() || (type.getBaseType() != null
            &amp;amp;&amp;amp; type.getBaseType().equals(relation.getType()));
    // 得到方向，pos 是 0 就是 out，是 1 就是 in
    Direction dir = EdgeDirection.fromPosition(position);
    
    // 方向验证
    Preconditions.checkArgument(type.isUnidirected(Direction.BOTH) || type.isUnidirected(dir));
    
    // 得到 typeId， 这个 type 是 VertexLabel 或者 PropertyKey
    long typeId = type.longId();
    // 得到 dirID 
    DirectionID dirID = getDirID(dir, relation.isProperty() ? RelationCategory.PROPERTY : RelationCategory.EDGE);
    
    // 得到 一个 out
    DataOutput out = serializer.getDataOutput(DEFAULT_CAPACITY);
    // key 和 value 的分割地址。
    int valuePosition;
    
    // 写 typeId 和 dirID 
    IDHandler.writeRelationType(out, typeId, dirID, type.isInvisibleType());
    
    // 得到 multiplicity 和 sortKey
    Multiplicity multiplicity = type.multiplicity();
    long[] sortKey = type.getSortKey();
    
    assert !multiplicity.isConstrained() || sortKey.length==0: type.name();
    int keyStartPos = out.getPosition();
    if (!multiplicity.isConstrained()) {
        // 如果 multiplicity 是 没有限制，也就是为 MULTI，必须要有 sortKey，写出 sortKey。
        writeInlineTypes(sortKey, relation, out, tx, InlineType.KEY);
    }
    
    // 到这里 key 就写完了，得到 key 的 pos
    int keyEndPos = out.getPosition();

    long relationId = relation.longId();

    //How multiplicity is handled for edges and properties is slightly different
    if (relation.isEdge()) {
        // 得到另一个 vertex 的 id
        long otherVertexId = relation.getVertex((position + 1) % 2).longId();
        // 如果 multiplicity 有限制
        if (multiplicity.isConstrained()) {
            // isUnique
            if (multiplicity.isUnique(dir)) {
                // 得到 valuePosition ，写出 otherVertexId 
                valuePosition = out.getPosition();
                VariableLong.writePositive(out, otherVertexId);
            } else {
                // 反方向写 otherVertexId ,记下 valuePosition
                VariableLong.writePositiveBackward(out, otherVertexId);
                valuePosition = out.getPosition();
            }
            // 写下 relationId
            VariableLong.writePositive(out, relationId);
        } else {
            // 没有限制，反方向写出 otherVertexId 和 relationId ，记下 valuePosition
            VariableLong.writePositiveBackward(out, otherVertexId);
            VariableLong.writePositiveBackward(out, relationId);
            valuePosition = out.getPosition();
        }
    } else { // PropertyKey
        assert relation.isProperty();
        Preconditions.checkArgument(relation.isProperty());
        // 得到 property 的值。
        Object value = ((JanusGraphVertexProperty) relation).value();
        Preconditions.checkNotNull(value);
        PropertyKey key = (PropertyKey) type;
        assert key.dataType().isInstance(value);
        
        // 写出 value 得到 valuePosition
        if (multiplicity.isConstrained()) { // 没有限制的 property
            if (multiplicity.isUnique(dir)) { //Cardinality=SINGLE
                valuePosition = out.getPosition();
                writePropertyValue(out,key,value);
            } else { //Cardinality=SET
                writePropertyValue(out,key,value);
                valuePosition = out.getPosition();
            }
            VariableLong.writePositive(out, relationId);
        } else {
            assert multiplicity.getCardinality()== Cardinality.LIST;
            VariableLong.writePositiveBackward(out, relationId);
            valuePosition = out.getPosition();
            writePropertyValue(out,key,value);
        }
    }

    //Write signature
    long[] signature = type.getSignature();
    writeInlineTypes(signature, relation, out, tx, InlineType.SIGNATURE);

    //Write remaining properties
    LongSet writtenTypes = new LongHashSet(sortKey.length + signature.length);
    if (sortKey.length &amp;gt; 0 || signature.length &amp;gt; 0) {
        for (long id : sortKey) writtenTypes.add(id);
        for (long id : signature) writtenTypes.add(id);
    }
    LongArrayList remainingTypes = new LongArrayList(8);
    for (PropertyKey t : relation.getPropertyKeysDirect()) {
        if (!(t instanceof ImplicitKey) &amp;amp;&amp;amp; !writtenTypes.contains(t.longId())) {
            remainingTypes.add(t.longId());
        }
    }
    //Sort types before writing to ensure that value is always written the same way
    long[] remaining = remainingTypes.toArray();
    Arrays.sort(remaining);
    for (long tid : remaining) {
        PropertyKey t = tx.getExistingPropertyKey(tid);
        writeInline(out, t, relation.getValueDirect(t), InlineType.NORMAL);
    }
    assert valuePosition&amp;gt;0;

    return new StaticArrayEntry(type.getSortOrder() == Order.DESC ?
                                out.getStaticBufferFlipBytes(keyStartPos, keyEndPos) :
                                out.getStaticBuffer(), valuePosition);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实就是不断吧值写进去并且记录一下值的位置。&lt;/p&gt;

&lt;p&gt;我们需要了解一下 writeInline 方法以及  StaticArrayEntry VariableLong 类。&lt;/p&gt;

&lt;h3 id=&#34;staticarrayentry&#34;&gt;StaticArrayEntry&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Entry (org.janusgraph.diskstorage)
BaseStaticArrayEntry (org.janusgraph.diskstorage.util)
StaticEntry in StaticArrayEntryList (org.janusgraph.diskstorage.util)
StaticArrayEntry (org.janusgraph.diskstorage.util)
SwappingEntry in StaticArrayEntryList (org.janusgraph.diskstorage.util)
StaticArrayEntry (org.janusgraph.diskstorage.util)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Entry 代表存储在 cassandra 基本结构，有 getColumn getValuePosition getValue 等方法，
BaseStaticArrayEntry 则是利用一个 array,offset,limit,valuePosition 进行封装。&lt;/p&gt;

&lt;h3 id=&#34;variablelong&#34;&gt;VariableLong&lt;/h3&gt;

&lt;p&gt;这个提供了一个读写Long类型的数据的方法，具体后续研究。&lt;/p&gt;

&lt;h3 id=&#34;writeinline&#34;&gt;writeInline&lt;/h3&gt;

&lt;p&gt;writeInline 方法实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void writeInlineTypes(long[] keyIds, InternalRelation relation, DataOutput out, TypeInspector tx,
                              InlineType inlineType) {
    for (long keyId : keyIds) {
        PropertyKey t = tx.getExistingPropertyKey(keyId);
        writeInline(out, t, relation.getValueDirect(t), inlineType);
    }
}

private void writeInline(DataOutput out, PropertyKey inlineKey, Object value, InlineType inlineType) {
    assert inlineType.writeInlineKey() || !AttributeUtil.hasGenericDataType(inlineKey);

    if (inlineType.writeInlineKey()) {
        IDHandler.writeInlineRelationType(out, inlineKey.longId());
    }

    writePropertyValue(out,inlineKey,value, inlineType);
}

private void writePropertyValue(DataOutput out, PropertyKey key, Object value, InlineType inlineType) {
    if (AttributeUtil.hasGenericDataType(key)) {
        assert !inlineType.writeByteOrdered();
        out.writeClassAndObject(value);
    } else {
        assert value==null || value.getClass().equals(key.dataType());
        if (inlineType.writeByteOrdered()) out.writeObjectByteOrder(value, key.dataType());
        else out.writeObject(value, key.dataType());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码我们可以看出，实际上都是对id进行的操作，所以如果知道了顶点的 id，给顶点添加边和属性，实际上不需要查询这个顶点，直接操作即可，所以这给我们导数据提供了一种思路，可以直接操作 id。&lt;/p&gt;

&lt;h2 id=&#34;writerelation-方法的参数怎么构造的&#34;&gt;writeRelation 方法的参数怎么构造的&lt;/h2&gt;

&lt;p&gt;从上面我们可以看出来 edgeSerializer.writeRelation 方法的参数是 (edge, type, pos, tx)，而 edge 来自于对 mutations 的处理，mutations 来自 add ,add 来自 addedRelations。&lt;/p&gt;

&lt;p&gt;addedRelations 进行 add 操作的步骤在 StandardJanusGraph 的 connectRelation(InternalRelation r) 方法中。connectRelation 方法有两处调用 addEdge 和 addProperty。&lt;/p&gt;

&lt;p&gt;addEdge 和 addProperty 的调用栈就比较多了。&lt;/p&gt;

&lt;h1 id=&#34;正向理清思路&#34;&gt;正向理清思路&lt;/h1&gt;

&lt;h2 id=&#34;1-janus-官网介绍&#34;&gt;1. janus 官网介绍&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.janusgraph.org/latest/schema.html&#34;&gt;https://docs.janusgraph.org/latest/schema.html&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;edge-label&#34;&gt;Edge Label&lt;/h3&gt;

&lt;p&gt;Multiplicity&lt;/p&gt;

&lt;p&gt;MULTI SIMPLE MANY2ONE ONE2MANY ONE2ONE 五种，每种的意义可以参考官网。默认的是 MULTI&lt;/p&gt;

&lt;h3 id=&#34;property-keys&#34;&gt;Property Keys&lt;/h3&gt;

&lt;p&gt;dataType(Class) 确定数据类型，Object.class 能够传入任何参数，但是不鼓励。&lt;/p&gt;

&lt;p&gt;Property Key Cardinality&lt;/p&gt;

&lt;p&gt;SINGLE: Allows at most one value per element for such key. In other words, the key→value mapping is unique for all elements in the graph. The property key birthDate is an example with SINGLE cardinality since each person has exactly one birth date.
LIST: Allows an arbitrary number of values per element for such key. In other words, the key is associated with a list of values allowing duplicate values. Assuming we model sensors as vertices in a graph, the property key sensorReading is an example with LIST cardinality to allow lots of (potentially duplicate) sensor readings to be recorded.
SET: Allows multiple values but no duplicate values per element for such key. In other words, the key is associated with a set of values. The property key name has SET cardinality if we want to capture all names of an individual (including nick name, maiden name, etc).&lt;/p&gt;

&lt;h3 id=&#34;relation-types&#34;&gt;Relation Types&lt;/h3&gt;

&lt;p&gt;Edge labels and property keys are jointly referred to as relation types ,must unique&lt;/p&gt;

&lt;h3 id=&#34;vertex-labels&#34;&gt;Vertex Labels&lt;/h3&gt;

&lt;p&gt;call makeVertexLabel(String).make()&lt;/p&gt;

&lt;h3 id=&#34;unidirected-edges&#34;&gt;Unidirected Edges&lt;/h3&gt;

&lt;p&gt;单向的边是只能在向外方向上遍历的边。单指向边具有较低的存储占用，但在它们支持的遍历类型中受到限制。单向的边在概念上类似于万维网中的超链接，在这个意义上，外顶点可以遍历边缘，但是顶点不知道它的存在。&lt;/p&gt;

&lt;h2 id=&#34;2-addproperty-和-addedge&#34;&gt;2. addProperty 和 addEdge&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public JanusGraphVertexProperty addProperty(VertexProperty.Cardinality cardinality, JanusGraphVertex vertex, PropertyKey key, Object value) {
    if (key.cardinality().convert()!=cardinality &amp;amp;&amp;amp; cardinality!=VertexProperty.Cardinality.single)
        throw new SchemaViolationException(&amp;quot;Key is defined for %s cardinality which conflicts with specified: %s&amp;quot;,key.cardinality(),cardinality);
    verifyWriteAccess(vertex);
    Preconditions.checkArgument(!(key instanceof ImplicitKey),&amp;quot;Cannot create a property of implicit type: %s&amp;quot;,key.name());
    vertex = ((InternalVertex) vertex).it();
    Preconditions.checkNotNull(key);
    checkPropertyConstraintForVertexOrCreatePropertyConstraint(vertex, key);
    final Object normalizedValue = verifyAttribute(key, value);
    
    // 得到 Cardinality SINGLE LIST SET ，一般是 SINGLE
    Cardinality keyCardinality = key.cardinality();
    
    // 省略部分代码
    try {
          // 省略检查
          
        StandardVertexProperty prop = new StandardVertexProperty(IDManager.getTemporaryRelationID(temporaryIds.nextID()), key, (InternalVertex) vertex, normalizedValue, ElementLifeCycle.New);
        if (config.hasAssignIDsImmediately()) graph.assignID(prop);
        connectRelation(prop);
        return prop;
    } finally {
        uniqueLock.unlock();
    }

}

public JanusGraphEdge addEdge(JanusGraphVertex outVertex, JanusGraphVertex inVertex, EdgeLabel label) {
    verifyWriteAccess(outVertex, inVertex);
    outVertex = ((InternalVertex) outVertex).it();
    inVertex = ((InternalVertex) inVertex).it();
    Preconditions.checkNotNull(label);
    checkConnectionConstraintOrCreateConnectionConstraint(outVertex, inVertex, label);
    Multiplicity multiplicity = label.multiplicity();
    TransactionLock uniqueLock = getUniquenessLock(outVertex, (InternalRelationType) label,inVertex);
    uniqueLock.lock(LOCK_TIMEOUT);
    try {
     // 省略检查
        StandardEdge edge = new StandardEdge(IDManager.getTemporaryRelationID(temporaryIds.nextID()), label, (InternalVertex) outVertex, (InternalVertex) inVertex, ElementLifeCycle.New);
        if (config.hasAssignIDsImmediately()) graph.assignID(edge);
        connectRelation(edge);
        return edge;
    } finally {
        uniqueLock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实这两个做的最主要的就两步： new StandardEdge new StandardVertexProperty  connectRelation(edge);&lt;/p&gt;

&lt;p&gt;connectRelation 最主要的就是 addedRelations.add&amp;reg;&lt;/p&gt;

&lt;p&gt;最后在 commit 的时候，会 处理  addedRelations，代码逻辑在上面我们已经看过了。我们在简化一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for (InternalRelation add : Iterables.filter(addedRelations,filter)) {
    Preconditions.checkArgument(add.isNew());

    for (int pos = 0; pos &amp;lt; add.getLen(); pos++) {
        InternalVertex vertex = add.getVertex(pos);
        if (pos == 0 || !add.isLoop()) {
            // 添加 mutations
            mutations.put(vertex.longId(), add);
        }
    }
}

// 
for (Long vertexId : mutations.keySet()) {

    final List&amp;lt;InternalRelation&amp;gt; edges = mutations.get(vertexId);
    final List&amp;lt;Entry&amp;gt; additions = new ArrayList&amp;lt;&amp;gt;(edges.size());
    final List&amp;lt;Entry&amp;gt; deletions = new ArrayList&amp;lt;&amp;gt;(Math.max(10, edges.size() / 10));
    
    for (final InternalRelation edge : edges) {
        final InternalRelationType baseType = (InternalRelationType) edge.getType();
        assert baseType.getBaseType()==null;

        for (InternalRelationType type : baseType.getRelationIndexes()) { // getRelationIndexes 这里是得到了 RelationTypeIndex 相关的 关系
            if (type.getStatus()== SchemaStatus.DISABLED) continue;
            for (int pos = 0; pos &amp;lt; edge.getArity(); pos++) {
                if (!type.isUnidirected(Direction.BOTH) &amp;amp;&amp;amp; !type.isUnidirected(EdgeDirection.fromPosition(pos)))
                    continue; //Directionality is not covered
                if (edge.getVertex(pos).longId()==vertexId) {
                    StaticArrayEntry entry = edgeSerializer.writeRelation(edge, type, pos, tx);
                    if (edge.isRemoved()) {
                        deletions.add(entry);
                    } else {
                        Preconditions.checkArgument(edge.isNew());
                        int ttl = getTTL(edge);
                        if (ttl &amp;gt; 0) {
                            entry.setMetaData(EntryMetaData.TTL, ttl);
                        }
                        additions.add(entry);
                    }
                }
            }
        }
    }

    StaticBuffer vertexKey = idManager.getKey(vertexId);
    mutator.mutateEdges(vertexKey, additions, deletions);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mutateedges&#34;&gt;mutateEdges&lt;/h2&gt;

&lt;p&gt;会逐步调用
edgeStore.mutateEntries(key, additions, deletions, storeTx);
mutateEntries(StaticBuffer key, List&lt;Entry&gt; additions, List&lt;Entry&gt; deletions, StoreTransaction txh)
mutate&lt;/p&gt;

&lt;p&gt;mutate 会将改变都记录到 mutations 中，在 flushInternal 的时候 mutations 会变换一下记录到 subMutations ，然后调用 persist(subMutations);
紧接着调用 manager.mutateMany(subMutations, tx); 最后重构成 cfmutation，通过 cassandra 的 CTConnection 保存到 cassandra 中。&lt;/p&gt;

&lt;p&gt;这样看来，整个过程就清晰了。&lt;/p&gt;

&lt;h2 id=&#34;id-分配&#34;&gt;id 分配&lt;/h2&gt;

&lt;p&gt;StandardIDPool 进行 id 的分配，调用 graph.assignID(schemaVertex, BaseVertexLabel.DEFAULT_VERTEXLABEL) 等方法的时候，会调用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;assignID:455, StandardJanusGraph (org.janusgraph.graphdb.database)
assignID:153, VertexIDAssigner (org.janusgraph.graphdb.database.idassigner)
assignID:182, VertexIDAssigner (org.janusgraph.graphdb.database.idassigner)
assignID:308, VertexIDAssigner (org.janusgraph.graphdb.database.idassigner)
nextID:204, StandardIDPool (org.janusgraph.graphdb.database.idassigner)
nextBlock:173, StandardIDPool (org.janusgraph.graphdb.database.idassigner)
startIDBlockGetter:247, StandardIDPool (org.janusgraph.graphdb.database.idassigner)

call:288, StandardIDPool$IDBlockGetter (org.janusgraph.graphdb.database.idassigner)
getIDBlock:213, ConsistentKeyIDAuthority (org.janusgraph.diskstorage.idmanagement)
    getBlockApplication:373, ConsistentKeyIDAuthority (org.janusgraph.diskstorage.idmanagement)
idStore.mutate(partitionKey, Arrays.asList(StaticArrayEntry.of(finalTarget)), KeyColumnValueStore.NO_DELETIONS, txh);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里涉及到了很多东西，而且是在两个线程中完成的，就不太方便处理了。&lt;/p&gt;

&lt;h3 id=&#34;vertexidassigner&#34;&gt;VertexIDAssigner&lt;/h3&gt;

&lt;p&gt;首先是 VertexIDAssigner 的创建：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public VertexIDAssigner(Configuration config, IDAuthority idAuthority, StoreFeatures idAuthFeatures) {
    Preconditions.checkNotNull(idAuthority);
    this.idAuthority = idAuthority;

    int partitionBits = NumberUtil.getPowerOf2(config.get(CLUSTER_MAX_PARTITIONS));
    idManager = new IDManager(partitionBits);
    Preconditions.checkArgument(idManager.getPartitionBound() &amp;lt;= Integer.MAX_VALUE &amp;amp;&amp;amp; idManager.getPartitionBound()&amp;gt;0);
    this.partitionIdBound = (int)idManager.getPartitionBound();
    hasLocalPartitions = idAuthFeatures.hasLocalKeyPartition();

    placementStrategy = Backend.getImplementationClass(config, config.get(PLACEMENT_STRATEGY),
            REGISTERED_PLACEMENT_STRATEGIES);
    placementStrategy.injectIDManager(idManager);
    log.debug(&amp;quot;Partition IDs? [{}], Local Partitions? [{}]&amp;quot;,true,hasLocalPartitions);

    long baseBlockSize = config.get(IDS_BLOCK_SIZE);
    idAuthority.setIDBlockSizer(new SimpleVertexIDBlockSizer(baseBlockSize));

    renewTimeoutMS = config.get(IDS_RENEW_TIMEOUT);
    renewBufferPercentage = config.get(IDS_RENEW_BUFFER_PERCENTAGE);

    idPools = new ConcurrentHashMap&amp;lt;Integer, PartitionIDPool&amp;gt;(partitionIdBound);
    schemaIdPool = new StandardIDPool(idAuthority, IDManager.SCHEMA_PARTITION, PoolType.SCHEMA.getIDNamespace(),
            IDManager.getSchemaCountBound(), renewTimeoutMS, renewBufferPercentage);
    partitionVertexIdPool = new StandardIDPool(idAuthority, IDManager.PARTITIONED_VERTEX_PARTITION, PoolType.PARTITIONED_VERTEX.getIDNamespace(),
            PoolType.PARTITIONED_VERTEX.getCountBound(idManager), renewTimeoutMS, renewBufferPercentage);
    setLocalPartitions(partitionBits);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;里面主要有 idAuthority , idManager(partitionBits=5) partitionIdBound=32  placementStrategy idPools schemaIdPool partitionVertexIdPool .&lt;/p&gt;

&lt;h4 id=&#34;assignid&#34;&gt;assignID&lt;/h4&gt;

&lt;p&gt;id 有三个部分组成 [0 count suffix partitionId],count，最高位是0，然后是后缀。后缀在 IDManager 中有配置,partitionId 默认是5位.
第一部是 得到 partitionID ，分为很多种情况，例如 schema 为0，分区的为 -1，vertex 的为 placementStrategy 随机获得。例如8， Relation 通过 incident 获得。&lt;/p&gt;

&lt;p&gt;然后才是 assignID
先得到 count ，得到过程是：
通过 partition 在 idPools 得到 PartitionIDPool，如果没有，新建 PartitionIDPool ，然后在每个 PartitionIDPool 中新建 3个 StandardIDPool ，分别对应 NORMAL_VERTEX, UNMODIFIABLE_VERTEX, RELATION;
在 PartitionIDPool 中得到现在的 element 所对应的 idPool，然后调用 count = idPool.nextID()  得到count ,nextID 会调用 currentBlock 得到 id。如果当前的 currentBlock 分配完了，重新申请一个 block&lt;/p&gt;

&lt;p&gt;调用 getId 方法的时候，会有一个 uniqueIDBitWidth ，默认是 4位，然后还有一个 unique 数值是0，最后返回的是得到的count 左右4位，如果是1，就是16.
返回了 count，然后构造的 结果就是 00000 0 000010000000&lt;/p&gt;

&lt;h3 id=&#34;standardidpool&#34;&gt;StandardIDPool&lt;/h3&gt;

&lt;p&gt;构造传入了：idAuthority partition idNamespace idUpperBound renewBufferPercentage
还有一个 exec ，用来执行线程。
还有 currentBlock currentIndex renewBlockIndex 记录当前的状态。&lt;/p&gt;

&lt;p&gt;###&lt;/p&gt;

&lt;p&gt;我们从 assignID 开始看。分为两步：&lt;/p&gt;

&lt;p&gt;partitionID = placementStrategy.getPartition(element);&lt;/p&gt;

&lt;h2 id=&#34;调试一次&#34;&gt;调试一次&lt;/h2&gt;

&lt;p&gt;接下来我们可以调试一次，通过调试过每一步，熟悉每一步的内容。&lt;/p&gt;

&lt;h1 id=&#34;bulk-loading&#34;&gt;bulk loading&lt;/h1&gt;

&lt;p&gt;接下来我们要做一个导数据的工具。我们有一堆给定好的书籍，然后我们能够将数据导入到 janus 中，我们需要结合 cassandra 和 hbase 自带的 bulk loading 工具。
首先我们需要得到所有的序列化的数据，实际上就是 edge 数据，而 index 的数据我们可以后续调用 reindex。&lt;/p&gt;

&lt;h2 id=&#34;vertex-导入&#34;&gt;vertex 导入&lt;/h2&gt;

&lt;p&gt;我们可以想象一下，导入边的流程，首先要有一个表格，并且这个表格要带有表头，然后下面的就是数据。表头包括字段名和数据类型，其中第一个是主键。例如有电话的数据，表头结构为：
phone:string,name:string,relation:integer&lt;/p&gt;

&lt;p&gt;我们程序首先是验证数据，验证数据主要是重复性检验，格式检验。然后需要创建 schema。读取所有的表头，并创建好 schema。然后导入数据。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>janusgraph源码分析8-索引存储</title>
      <link>https://dengziming.github.io/post/titan/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%908-%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8/</link>
      <pubDate>Mon, 09 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/titan/janusgraph%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%908-%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8/</guid>
      
        <description>

&lt;p&gt;上一节我们了解了 JanusGraph 的关系存储，主要是在 EdgeSerializer 中的序列化和反序列化，我们还要这次看看 IndexSerializer 的相关类。&lt;/p&gt;

&lt;h1 id=&#34;基础类&#34;&gt;基础类&lt;/h1&gt;

&lt;h2 id=&#34;indexserializer&#34;&gt;IndexSerializer&lt;/h2&gt;

&lt;p&gt;用来序列化，反序列化&lt;/p&gt;

&lt;h2 id=&#34;indexprovider&#34;&gt;IndexProvider&lt;/h2&gt;

&lt;p&gt;IndexProvider 继承自 IndexInformation ，IndexInformation 主要判断是否支持某个 KeyInformation，
IndexProvider 最主要的是 mutate 方法，该方法就是用来保存数据到底层存储系统。&lt;/p&gt;

&lt;h2 id=&#34;keyinformation&#34;&gt;KeyInformation&lt;/h2&gt;

&lt;p&gt;保存key的信息，有三个内部接口&lt;/p&gt;

&lt;h3 id=&#34;storeretriever&#34;&gt;StoreRetriever&lt;/h3&gt;

&lt;p&gt;能够根据key得到 KeyInformation&lt;/p&gt;

&lt;h3 id=&#34;indexretriever&#34;&gt;IndexRetriever&lt;/h3&gt;

&lt;p&gt;能够根据key 和 store得到 KeyInformation
根据store 得到 StoreRetriever&lt;/p&gt;

&lt;h3 id=&#34;retriever&#34;&gt;Retriever&lt;/h3&gt;

&lt;p&gt;根据 index 得到IndexRetriever&lt;/p&gt;

&lt;p&gt;这几个比较混乱。主要实现在 IndexInfoRetriever 中。&lt;/p&gt;

&lt;h2 id=&#34;indexserializer-indexinforetriever&#34;&gt;IndexSerializer.IndexInfoRetriever&lt;/h2&gt;

&lt;p&gt;IndexInfoRetriever 继承自 KeyInformation.Retriever，只有一个 get 方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static class IndexInfoRetriever implements KeyInformation.Retriever {

    private final StandardJanusGraphTx transaction;

    private IndexInfoRetriever(StandardJanusGraphTx tx) {
        Preconditions.checkNotNull(tx);
        transaction=tx;
    }

    @Override
    public KeyInformation.IndexRetriever get(final String index) {
        return new KeyInformation.IndexRetriever() {

            final Map&amp;lt;String,KeyInformation.StoreRetriever&amp;gt; indexes = new ConcurrentHashMap&amp;lt;&amp;gt;();

            @Override
            public KeyInformation get(String store, String key) {
                return get(store).get(key);
            }

            @Override
            public KeyInformation.StoreRetriever get(final String store) {
                if (indexes.get(store)==null) {
                    Preconditions.checkState(transaction!=null,&amp;quot;Retriever has not been initialized&amp;quot;);
                    final MixedIndexType extIndex = getMixedIndex(store, transaction);
                    assert extIndex.getBackingIndexName().equals(index);
                    final ImmutableMap.Builder&amp;lt;String,KeyInformation&amp;gt; b = ImmutableMap.builder();
                    for (final ParameterIndexField field : extIndex.getFieldKeys()) b.put(key2Field(field),getKeyInformation(field));
                    final ImmutableMap&amp;lt;String,KeyInformation&amp;gt; infoMap = b.build();
                    final KeyInformation.StoreRetriever storeRetriever = infoMap::get;
                    indexes.put(store,storeRetriever);
                }
                return indexes.get(store);
            }

        };
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过看代码，我们发现其实都是几个map。
1. 首先 IndexInfoRetriever 里面有个 &lt;code&gt;final Map&amp;lt;String,KeyInformation.StoreRetriever&amp;gt; indexes = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;/code&gt;
2. KeyInformation.StoreRetriever 实际上也就是一个 &lt;code&gt;final ImmutableMap&amp;lt;String,KeyInformation&amp;gt; infoMap = b.build();&lt;/code&gt;
3. 调用 IndexInfoRetriever 的 get 方法，会调用getMixedIndex(store, transaction); 也就是说这个得到的只是 MixedIndexType。&lt;/p&gt;

&lt;h2 id=&#34;recordentry&#34;&gt;RecordEntry&lt;/h2&gt;

&lt;p&gt;这个类 有三个属性，分别是 long relationId, Object value, PropertyKey key，这应该就代表了待建索引的一个记录。&lt;/p&gt;

&lt;h2 id=&#34;indexrecords&#34;&gt;IndexRecords&lt;/h2&gt;

&lt;p&gt;public static class IndexRecords extends ArrayList&lt;RecordEntry[]&gt;&lt;/p&gt;

&lt;p&gt;看上去像一个二维数组，记录索引的更新。&lt;/p&gt;

&lt;h2 id=&#34;indexupdate&#34;&gt;IndexUpdate&lt;/h2&gt;

&lt;p&gt;这个类主要是提供一些计算索引更新的工具方法。&lt;/p&gt;

&lt;h2 id=&#34;索引回顾&#34;&gt;索引回顾&lt;/h2&gt;

&lt;p&gt;我们先回顾一下相关知识，主要是我们建索引的时候发生了什么。&lt;code&gt;JanusGraphIndex nameIndex = management.buildIndex(&amp;quot;name&amp;quot;, Vertex.class).addKey(name).buildCompositeIndex();&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private JanusGraphIndex createCompositeIndex(String indexName, ElementCategory elementCategory, boolean unique, JanusGraphSchemaType constraint, PropertyKey... keys) {
    // 
    Preconditions.checkArgument(!unique || elementCategory == ElementCategory.VERTEX, &amp;quot;Unique indexes can only be created on vertices [%s]&amp;quot;, indexName);
    boolean allSingleKeys = true;
    boolean oneNewKey = false;
    for (PropertyKey key : keys) {
        if (key.cardinality() != Cardinality.SINGLE) allSingleKeys = false;
        if (key.isNew()) oneNewKey = true;
        else updatedTypes.add((PropertyKeyVertex) key);
    }

    Cardinality indexCardinality;
    if (unique) indexCardinality = Cardinality.SINGLE;
    else indexCardinality = (allSingleKeys ? Cardinality.SET : Cardinality.LIST);

    boolean canIndexBeEnabled = oneNewKey || (constraint != null &amp;amp;&amp;amp; constraint.isNew());

    TypeDefinitionMap def = new TypeDefinitionMap();
    def.setValue(TypeDefinitionCategory.INTERNAL_INDEX, true);
    def.setValue(TypeDefinitionCategory.ELEMENT_CATEGORY, elementCategory);
    def.setValue(TypeDefinitionCategory.BACKING_INDEX, Token.INTERNAL_INDEX_NAME);
    def.setValue(TypeDefinitionCategory.INDEXSTORE_NAME, indexName);
    def.setValue(TypeDefinitionCategory.INDEX_CARDINALITY, indexCardinality);
    def.setValue(TypeDefinitionCategory.STATUS, canIndexBeEnabled ? SchemaStatus.ENABLED : SchemaStatus.INSTALLED);
    // 新建一个顶点。
    JanusGraphSchemaVertex indexVertex = transaction.makeSchemaVertex(JanusGraphSchemaCategory.GRAPHINDEX, indexName, def);
    for (int i = 0; i &amp;lt; keys.length; i++) {
        Parameter[] paras = {ParameterType.INDEX_POSITION.getParameter(i)};
        // 添加边，顶点分别是两个 index 和 propertykey
        addSchemaEdge(indexVertex, keys[i], TypeDefinitionCategory.INDEX_FIELD, paras);
    }

    Preconditions.checkArgument(constraint == null || (elementCategory.isValidConstraint(constraint) &amp;amp;&amp;amp; constraint instanceof JanusGraphSchemaVertex));
    if (constraint != null) {
        // 如果加了限制 ，在添加一条边。
        addSchemaEdge(indexVertex, (JanusGraphSchemaVertex) constraint, TypeDefinitionCategory.INDEX_SCHEMA_CONSTRAINT, null);
    }
    updateSchemaVertex(indexVertex);
    JanusGraphIndexWrapper index = new JanusGraphIndexWrapper(indexVertex.asIndexType());
    if (!oneNewKey) updateIndex(index, SchemaAction.REGISTER_INDEX);
    return index;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;addSchemaEdge 方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public JanusGraphEdge addSchemaEdge(JanusGraphVertex out, JanusGraphVertex in, TypeDefinitionCategory def, Object modifier) {
    assert def.isEdge();
    // 加一条边，边的 label 是 SchemaDefinitionEdge
    JanusGraphEdge edge = addEdge(out, in, BaseLabel.SchemaDefinitionEdge);
    TypeDefinitionDescription desc = new TypeDefinitionDescription(def, modifier);
    edge.property(BaseKey.SchemaDefinitionDesc.name(), desc);
    return edge;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出其实就是新建一个 顶点，添加属性，然后添加边。&lt;/p&gt;

&lt;h2 id=&#34;indexserializer-getindexupdates-del&#34;&gt;indexSerializer.getIndexUpdates(del)&lt;/h2&gt;

&lt;p&gt;我们现在就看看 index 如何序列化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Collection&amp;lt;IndexUpdate&amp;gt; getIndexUpdates(InternalRelation relation) {
    assert relation.isNew() || relation.isRemoved();
    final Set&amp;lt;IndexUpdate&amp;gt; updates = Sets.newHashSet();
    final IndexUpdate.Type updateType = getUpdateType(relation);
    final int ttl = updateType==IndexUpdate.Type.ADD?StandardJanusGraph.getTTL(relation):0;
    for (final RelationType type : relation.getPropertyKeysDirect()) {
        if (!(type instanceof PropertyKey)) continue;
        final PropertyKey key = (PropertyKey)type;
        for (final IndexType index : ((InternalRelationType)key).getKeyIndexes()) {
            if (!indexAppliesTo(index,relation)) continue;
            IndexUpdate update;
            if (index instanceof CompositeIndexType) {
                final CompositeIndexType iIndex= (CompositeIndexType) index;
                final RecordEntry[] record = indexMatch(relation, iIndex);
                if (record==null) continue;
                update = new IndexUpdate&amp;lt;&amp;gt;(iIndex, updateType, getIndexKey(iIndex, record), getIndexEntry(iIndex, record, relation), relation);
            } else {
                assert relation.valueOrNull(key)!=null;
                if (((MixedIndexType)index).getField(key).getStatus()== SchemaStatus.DISABLED) continue;
                update = getMixedIndexUpdate(relation, key, relation.valueOrNull(key), (MixedIndexType) index, updateType);
            }
            if (ttl&amp;gt;0) update.setTTL(ttl);
            updates.add(update);
        }
    }
    return updates;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;compositeindextype&#34;&gt;CompositeIndexType&lt;/h3&gt;

&lt;p&gt;我们先看 CompositeIndexType 部分，我们发现主要就是 indexMatch 方法 和 new IndexUpdate，得到某个 relation 相关的index：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static RecordEntry[] indexMatch(JanusGraphRelation relation, CompositeIndexType index) {
    // 得到所有的key。
    final IndexField[] fields = index.getFieldKeys();
    // 新建一个对应的数组
    final RecordEntry[] match = new RecordEntry[fields.length];
    for (int i = 0; i &amp;lt;fields.length; i++) {
        final IndexField f = fields[i];
        final Object value = relation.valueOrNull(f.getFieldKey());
        if (value==null) return null; //No match
        match[i] = new RecordEntry(relation.longId(),value,f.getFieldKey());
    }
    return match;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;总的来说还是很简单的，得到所有的索引字段的值即可，但是假如一个索引有两个字段，我们每次更新其中一个字段，都会更新一次索引，这岂不是会很麻烦。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private StaticBuffer getIndexKey(CompositeIndexType index, Object[] values) {
    final DataOutput out = serializer.getDataOutput(8*DEFAULT_OBJECT_BYTELEN + 8);
    // 写入 indexType 的 ID
    VariableLong.writePositive(out, index.getID());
    final IndexField[] fields = index.getFieldKeys();
    Preconditions.checkArgument(fields.length&amp;gt;0 &amp;amp;&amp;amp; fields.length==values.length);
    for (int i = 0; i &amp;lt; fields.length; i++) {
        final IndexField f = fields[i];
        final Object value = values[i];
        Preconditions.checkNotNull(value);
        // 写入 index 的值。
        if (AttributeUtil.hasGenericDataType(f.getFieldKey())) {
            out.writeClassAndObject(value);
        } else {
            assert value.getClass().equals(f.getFieldKey().dataType()) : value.getClass() + &amp;quot; - &amp;quot; + f.getFieldKey().dataType();
            out.writeObjectNotNull(value);
        }
    }
    StaticBuffer key = out.getStaticBuffer();
    if (hashKeys) key = HashingUtil.hashPrefixKey(hashLength,key);
    return key;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出 compositeindex 数据的key结构，indexId+value(所有的)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Entry getIndexEntry(CompositeIndexType index, RecordEntry[] record, JanusGraphElement element) {
    final DataOutput out = serializer.getDataOutput(1+8+8*record.length+4*8);
    out.putByte(FIRST_INDEX_COLUMN_BYTE);
    if (index.getCardinality()!=Cardinality.SINGLE) { // 代表是 SET 或者 LIST
        // 写出 value 的 id
        VariableLong.writePositive(out,element.longId());
        if (index.getCardinality()!=Cardinality.SET) { // 如果是LIST
            // 循环写出 relationId
            for (final RecordEntry re : record) {
                VariableLong.writePositive(out,re.relationId);
            }
        }
    }
    // column 和 value 的分界点。
    final int valuePosition=out.getPosition();
    if (element instanceof JanusGraphVertex) { // 如果是顶点
        VariableLong.writePositive(out,element.longId());
    } else {
        assert element instanceof JanusGraphRelation;
        final RelationIdentifier rid = (RelationIdentifier)element.id();
        final long[] longs = rid.getLongRepresentation();
        Preconditions.checkArgument(longs.length == 3 || longs.length == 4);
        for (final long aLong : longs) VariableLong.writePositive(out, aLong);
    }
    return new StaticArrayEntry(out.getStaticBuffer(),valuePosition);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个都比较类似的，按照固定的格式，生成看key 和value。&lt;/p&gt;

&lt;h3 id=&#34;getmixedindexupdate&#34;&gt;getMixedIndexUpdate&lt;/h3&gt;

&lt;p&gt;上面看的是 compositeIndex 的序列化过程，还有 MixedIndex。&lt;code&gt;return new IndexUpdate&amp;lt;&amp;gt;(index, updateType, element2String(element), new IndexEntry(key2Field(index.getField(key)), value), element);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static String element2String(Object elementId) {
    if (elementId instanceof Long) return longID2Name((Long)elementId);
    else return ((RelationIdentifier) elementId).toString();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private static String key2Field(ParameterIndexField field) {
    assert field!=null;
    return ParameterType.MAPPED_NAME.findParameter(field.getParameters(),keyID2Name(field.getFieldKey()));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这两个部分有很多其他的类，比较乱，后续可以自己整理一下，但是整体意思就是得到一个 key value 的类。。&lt;/p&gt;

&lt;h2 id=&#34;反序列化查询&#34;&gt;反序列化查询&lt;/h2&gt;

&lt;p&gt;查询过程稍微有点复杂，一般会通过读索引。后续进行分析。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>