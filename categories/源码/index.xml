<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>源码 on 数据分析师之旅</title>
    <link>https://dengziming.github.io/categories/%E6%BA%90%E7%A0%81/</link>
    <description>Recent content in 源码 on 数据分析师之旅</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 30 Oct 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://dengziming.github.io/categories/%E6%BA%90%E7%A0%81/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>tinkerpop源码解析1-简单例子debug</title>
      <link>https://dengziming.github.io/post/tinkerpop/tinkerpop%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901-%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90debug/</link>
      <pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/tinkerpop/tinkerpop%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%901-%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90debug/</guid>
      
        <description>

&lt;p&gt;tinkerpop 源码是JanusGraph 源码解析的第一步，我们需要大概有个了解。&lt;/p&gt;

&lt;h2 id=&#34;demo-编写&#34;&gt;demo 编写&lt;/h2&gt;

&lt;p&gt;我们可以直接复制来自 tinkerpop 官方的源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {

    TinkerGraph graph = TinkerGraph.open();
    GraphTraversalSource g = graph.traversal();

    Vertex v = g.addV().property(&amp;quot;name&amp;quot;,&amp;quot;marko&amp;quot;).property(&amp;quot;nam&amp;quot;,&amp;quot;marko a. rodriguez&amp;quot;).next();

    GraphTraversal&amp;lt;Vertex, Long&amp;gt; name = g.V(v).properties(&amp;quot;name&amp;quot;).count();
    v.property(list, &amp;quot;name&amp;quot;, &amp;quot;m. a. rodriguez&amp;quot;);
    g.V(v).properties(&amp;quot;name&amp;quot;).count();
    g.V(v).properties();
    g.V(v).properties(&amp;quot;name&amp;quot;);
    g.V(v).properties(&amp;quot;name&amp;quot;).hasValue(&amp;quot;marko&amp;quot;);
    g.V(v).properties(&amp;quot;name&amp;quot;).hasValue(&amp;quot;marko&amp;quot;).property(&amp;quot;acl&amp;quot;,&amp;quot;private&amp;quot;); //
    g.V(v).properties(&amp;quot;name&amp;quot;).hasValue(&amp;quot;marko a. rodriguez&amp;quot;);
    g.V(v).properties(&amp;quot;name&amp;quot;).hasValue(&amp;quot;marko a. rodriguez&amp;quot;).property(&amp;quot;acl&amp;quot;,&amp;quot;public&amp;quot;);
    g.V(v).properties(&amp;quot;name&amp;quot;).has(&amp;quot;acl&amp;quot;,&amp;quot;public&amp;quot;).value();
    g.V(v).properties(&amp;quot;name&amp;quot;).has(&amp;quot;acl&amp;quot;,&amp;quot;public&amp;quot;).drop(); //4\
    g.V(v).properties(&amp;quot;name&amp;quot;).has(&amp;quot;acl&amp;quot;,&amp;quot;public&amp;quot;).value();
    g.V(v).properties(&amp;quot;name&amp;quot;).has(&amp;quot;acl&amp;quot;,&amp;quot;private&amp;quot;).value();
    g.V(v).properties();
    g.V(v).properties().properties(); //5\
    g.V(v).properties().property(&amp;quot;date&amp;quot;,2014) ;//6\
    g.V(v).properties().property(&amp;quot;creator&amp;quot;,&amp;quot;stephen&amp;quot;);
    g.V(v).properties().properties();
    g.V(v).properties(&amp;quot;name&amp;quot;).valueMap();
    g.V(v).property(&amp;quot;name&amp;quot;,&amp;quot;okram&amp;quot;); //7\
    g.V(v).properties(&amp;quot;name&amp;quot;);
    g.V(v).values(&amp;quot;name&amp;quot;); //8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后从第一行开始 打断点，debug。首先注意 TinkerGraph 是一个很简单的图数据库，超级简单。&lt;/p&gt;

&lt;h2 id=&#34;tinkergraph&#34;&gt;TinkerGraph&lt;/h2&gt;

&lt;p&gt;TinkerGraph.open() 方法会新建一个 TinkerGraph：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private TinkerGraph(final Configuration configuration) {
    this.configuration = configuration;
    vertexIdManager = selectIdManager(configuration, GREMLIN_TINKERGRAPH_VERTEX_ID_MANAGER, Vertex.class);
    edgeIdManager = selectIdManager(configuration, GREMLIN_TINKERGRAPH_EDGE_ID_MANAGER, Edge.class);
    vertexPropertyIdManager = selectIdManager(configuration, GREMLIN_TINKERGRAPH_VERTEX_PROPERTY_ID_MANAGER, VertexProperty.class);
    defaultVertexPropertyCardinality = VertexProperty.Cardinality.valueOf(
            configuration.getString(GREMLIN_TINKERGRAPH_DEFAULT_VERTEX_PROPERTY_CARDINALITY, VertexProperty.Cardinality.single.name()));

    graphLocation = configuration.getString(GREMLIN_TINKERGRAPH_GRAPH_LOCATION, null);
    graphFormat = configuration.getString(GREMLIN_TINKERGRAPH_GRAPH_FORMAT, null);

    if ((graphLocation != null &amp;amp;&amp;amp; null == graphFormat) || (null == graphLocation &amp;amp;&amp;amp; graphFormat != null))
        throw new IllegalStateException(String.format(&amp;quot;The %s and %s must both be specified if either is present&amp;quot;,
                GREMLIN_TINKERGRAPH_GRAPH_LOCATION, GREMLIN_TINKERGRAPH_GRAPH_FORMAT));

    if (graphLocation != null) loadGraph();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的 configuration 类似一个map。然后有几个 IDManager 和其他变量赋值。&lt;/p&gt;

&lt;p&gt;然后是 GraphTraversalSource g = graph.traversal(); 这一句仅仅是 return new GraphTraversalSource(this);&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public GraphTraversalSource(final Graph graph) {
    this(graph, TraversalStrategies.GlobalCache.getStrategies(graph.getClass()));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候我们取看一下几个特殊的类： Traversal&lt;S,E&gt; Traversal.Admin&lt;S, E&gt; 。 他们两个都是接口，而且 Admin 是继承自 Traversal。
Traversal 代表遍历，主要方法包括 next， asNext，iterator toList 等，可以看成一个迭代器，而 Admin 的主要方法和他没有什么关系。&lt;/p&gt;

&lt;p&gt;GraphTraversal&lt;S, E&gt; extends Traversal&lt;S, E&gt; , 新增加了很多和 gremlin 相关的方法。这属于 tinkerpop 的内容&lt;/p&gt;

&lt;p&gt;然后是 addVertex&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Vertex addVertex(final Object... keyValues) {
    ElementHelper.legalPropertyKeyValueArray(keyValues);
    Object idValue = vertexIdManager.convert(ElementHelper.getIdValue(keyValues).orElse(null));
    final String label = ElementHelper.getLabelValue(keyValues).orElse(Vertex.DEFAULT_LABEL);

    if (null != idValue) {
        if (this.vertices.containsKey(idValue))
            throw Exceptions.vertexWithIdAlreadyExists(idValue);
    } else {
        idValue = vertexIdManager.getNextId(this);
    }

    final Vertex vertex = new TinkerVertex(idValue, label, this);
    this.vertices.put(vertex.id(), vertex);

    ElementHelper.attachProperties(vertex, VertexProperty.Cardinality.list, keyValues);
    return vertex;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看出源码十分简单，而且 property 等方法就更简单了，所以 TinkerGraph 可以用来进行后续的分析。这样有关图操作部分就不会有理解难度。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>tinkerpop源码解析3-策略植入</title>
      <link>https://dengziming.github.io/post/tinkerpop/tinkerpop%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%903-%E7%AD%96%E7%95%A5%E6%A4%8D%E5%85%A5/</link>
      <pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/tinkerpop/tinkerpop%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%903-%E7%AD%96%E7%95%A5%E6%A4%8D%E5%85%A5/</guid>
      
        <description>

&lt;p&gt;前面我们大概看了tinkerpop 的代码怎么一步步变成 Traversal 和 Step，然后怎么调用和执行。我们忽略了 strategy 的相关操作。&lt;/p&gt;

&lt;h2 id=&#34;官方介绍&#34;&gt;官方介绍&lt;/h2&gt;

&lt;p&gt;在查看源码之前我们尽量对她进行了解熟悉。TraversalStrategy 分析 Traversal，如果 Traversal 符合其标准尺度，则可以相应地进行改变。
strategies 在编译期执行，是 Gremlin traversal machine 编译器的基础，分为五种类型：
1. 可以直接嵌入 traversal 逻辑的 application-level 的功能（decoration）；
2. 能够更高效通过 TinkerPop3 语法表达 traversal （optimization）；
3. 能够更高效在 graph 层面表达traversal（provider optimization）；
4. 在执行 traversal 之前 一些必须的最终适配、清理、分析 (finalization)；
5. 对于当前的程序或者存储系统来说，一些不合法的操作(verification)。&lt;/p&gt;

&lt;p&gt;以 IdentityRemovalStrategy 为例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public final class IdentityRemovalStrategy extends AbstractTraversalStrategy&amp;lt;TraversalStrategy.OptimizationStrategy&amp;gt; implements TraversalStrategy.OptimizationStrategy {

    private static final IdentityRemovalStrategy INSTANCE = new IdentityRemovalStrategy();

    private IdentityRemovalStrategy() {
    }

    @Override
    public void apply(Traversal.Admin&amp;lt;?, ?&amp;gt; traversal) {
        if (traversal.getSteps().size() &amp;lt;= 1)
            return;

        for (IdentityStep&amp;lt;?&amp;gt; identityStep : TraversalHelper.getStepsOfClass(IdentityStep.class, traversal)) {
            if (identityStep.getLabels().isEmpty() || !(identityStep.getPreviousStep() instanceof EmptyStep)) {
                TraversalHelper.copyLabels(identityStep, identityStep.getPreviousStep(), false);
                traversal.removeStep(identityStep);
            }
        }
    }

    public static IdentityRemovalStrategy instance() {
        return INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出继承自 AbstractTraversalStrategy， 和 TraversalStrategy.OptimizationStrategy，并有一个 apply(Traversal.Admin&amp;lt;?, ?&amp;gt; traversal)  方法。
这里是直接在 traversal 中找到 identityStep 并移除。&lt;/p&gt;

&lt;h2 id=&#34;applystrategies&#34;&gt;applyStrategies&lt;/h2&gt;

&lt;p&gt;strategies 初始化的时候就放入graph 中，我们这里看看如何嵌入到查询语句。&lt;/p&gt;

&lt;p&gt;在我们调用 traversal.next() 之前，有个步骤就是 applyStrategies。在执行 traversal 之前大概是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this = {DefaultGraphTraversal@1359} &amp;quot;[GraphStep(vertex,[1]), VertexStep(OUT,[knows],edge), EdgeVertexStep(IN), PropertiesStep([name],value)]&amp;quot;
 lastTraverser = {EmptyTraverser@1384} 
 finalEndStep = {EmptyStep@1385} 
 stepPosition = {StepPosition@1362} &amp;quot;4.0.0()&amp;quot;
 graph = {TinkerGraph@1386} &amp;quot;tinkergraph[vertices:6 edges:6]&amp;quot;
 steps = {ArrayList@1387}  size = 4
 unmodifiableSteps = {Collections$UnmodifiableRandomAccessList@1388}  size = 4
 parent = {EmptyStep@1385} 
 sideEffects = {DefaultTraversalSideEffects@1389} &amp;quot;sideEffects[size:0]&amp;quot;
 strategies = {DefaultTraversalStrategies@1361} &amp;quot;strategies[ConnectiveStrategy, IncidentToAdjacentStrategy, MatchPredicateStrategy, FilterRankingStrategy, InlineFilterStrategy, AdjacentToIncidentStrategy, RepeatUnrollStrategy, PathRetractionStrategy, CountStrategy, LazyBarrierStrategy, TinkerGraphCountStrategy, TinkerGraphStepStrategy, ProfileStrategy, StandardVerificationStrategy]&amp;quot;
 generator = null
 requirements = null
 locked = false
 bytecode = {Bytecode@1390} &amp;quot;[[], [V(1), outE(knows), inV(), values(name)]]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出是 DefaultGraphTraversal 的实体类，lastTraverser finalEndStep parent sideEffects 都是刚初始化，steps unmodifiableSteps 是4个。
然后我们执行完这个方法再来看看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;this = {DefaultGraphTraversal@1359} &amp;quot;[TinkerGraphStep(vertex,[1]), VertexStep(OUT,[knows],vertex), PropertiesStep([name],value)]&amp;quot;
 lastTraverser = {EmptyTraverser@1384} 
 finalEndStep = {PropertiesStep@1432} &amp;quot;PropertiesStep([name],value)&amp;quot;
 stepPosition = {StepPosition@1362} &amp;quot;6.0.0()&amp;quot;
 graph = {TinkerGraph@1386} &amp;quot;tinkergraph[vertices:6 edges:6]&amp;quot;
 steps = {ArrayList@1387}  size = 3
 unmodifiableSteps = {Collections$UnmodifiableRandomAccessList@1388}  size = 3
 parent = {EmptyStep@1385} 
 sideEffects = {DefaultTraversalSideEffects@1389} &amp;quot;sideEffects[size:0]&amp;quot;
 strategies = {DefaultTraversalStrategies@1361} &amp;quot;strategies[ConnectiveStrategy, IncidentToAdjacentStrategy, MatchPredicateStrategy, FilterRankingStrategy, InlineFilterStrategy, AdjacentToIncidentStrategy, RepeatUnrollStrategy, PathRetractionStrategy, CountStrategy, LazyBarrierStrategy, TinkerGraphCountStrategy, TinkerGraphStepStrategy, ProfileStrategy, StandardVerificationStrategy]&amp;quot;
 generator = null
 requirements = {Collections$UnmodifiableSet@1431}  size = 1
 locked = true
 bytecode = {Bytecode@1390} &amp;quot;[[], [V(1), outE(knows), inV(), values(name)]]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;finalEndStep 变了，stepPosition 变了，steps unmodifiableSteps 都少了一步，requirements 多了一个。然后我们还是具体看看方法执行步骤：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void applyStrategies() throws IllegalStateException {
    if (this.locked) throw Traversal.Exceptions.traversalIsLocked(); // 判断是否执行过。
    TraversalHelper.reIdSteps(this.stepPosition, this);
    this.strategies.applyStrategies(this); // 这一步循环调用 strategy 的 apply 方法。
    {
        for (final TraversalStrategy&amp;lt;?&amp;gt; traversalStrategy : this.traversalStrategies) {
            traversalStrategy.apply(traversal);
        }
    }
    boolean hasGraph = null != this.graph;
    
    // 判断 TraversalParent 的所有 globalChild 也要进行 applyStrategies
    for (int i = 0, j = this.steps.size(); i &amp;lt; j; i++) { // &amp;quot;foreach&amp;quot; can lead to ConcurrentModificationExceptions
        final Step step = this.steps.get(i);
        if (step instanceof TraversalParent) {
            for (final Traversal.Admin&amp;lt;?, ?&amp;gt; globalChild : ((TraversalParent) step).getGlobalChildren()) {
                globalChild.setStrategies(this.strategies);
                globalChild.setSideEffects(this.sideEffects);
                if (hasGraph) globalChild.setGraph(this.graph);
                globalChild.applyStrategies();
            }
            for (final Traversal.Admin&amp;lt;?, ?&amp;gt; localChild : ((TraversalParent) step).getLocalChildren()) {
                localChild.setStrategies(this.strategies);
                localChild.setSideEffects(this.sideEffects);
                if (hasGraph) localChild.setGraph(this.graph);
                localChild.applyStrategies();
            }
        }
    }
    // 得到 finalEndStep 
    this.finalEndStep = this.getEndStep();
    // finalize requirements
    if (this.getParent() instanceof EmptyStep) {
        this.requirements = null;
        this.getTraverserRequirements();
    }
    this.locked = true;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整段代码并不复杂，复杂的是每个 traversalStrategy 具体都做了什么。&lt;/p&gt;

&lt;p&gt;我们知道 tinkerpop 是一个独立的项目，里面是不带任何和 janus 相关的内容，如何会有 JanusGraphStep 呢，
其实在很多地方（例如 fill:175, Traversal (org.apache.tinkerpop.gremlin.process.traversal)）会调用 this.asAdmin().applyStrategies();
会循环调用 traversalStrategy.apply(traversal)。在 apply 方法中得到了所有的 GraphStep。然后 new JanusGraphStep ，并且替换掉原有的 step。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>