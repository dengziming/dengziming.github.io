<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>开发经验 on 数据分析师之旅</title>
    <link>https://dengziming.github.io/categories/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/</link>
    <description>Recent content in 开发经验 on 数据分析师之旅</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 22 Feb 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://dengziming.github.io/categories/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>cassandra使用</title>
      <link>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/cassandra/</link>
      <pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/cassandra/</guid>
      
        <description>

&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;

&lt;p&gt;查看压缩转态：&lt;/p&gt;

&lt;p&gt;bin/nodetool compactionstats&lt;/p&gt;

&lt;p&gt;bin/nodetool disableautocompaction 可以禁用 compact，bin/nodetool enableautocompaction 启用&lt;/p&gt;

&lt;h2 id=&#34;参数配置&#34;&gt;参数配置&lt;/h2&gt;

&lt;p&gt;使用时候注意参数设置&lt;/p&gt;

&lt;p&gt;alter table titan_20190104.edgestore with compaction = {&amp;lsquo;class&amp;rsquo;: &amp;lsquo;org.apache.cassandra.db.compaction.LeveledCompactionStrategy&amp;rsquo;, &amp;lsquo;sstable_size_in_mb&amp;rsquo;: 512};
alter table titan_20190104.edgestore with compression = {&amp;lsquo;chunk_length_in_kb&amp;rsquo;: &amp;lsquo;1024&amp;rsquo;, &amp;lsquo;class&amp;rsquo;: &amp;lsquo;org.apache.cassandra.io.compress.LZ4Compressor&amp;rsquo;};
alter table titan_20190104.edgestore with gc_grace_seconds = 259200;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>常见错误及经验</title>
      <link>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</link>
      <pubDate>Thu, 06 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</guid>
      
        <description>&lt;p&gt;File file:/opt/hdfsi/yarn/nm/usercache/b_kg_fin_user/appcache/application_1543365716015_968403 does not exist
定位问题为节点问题，权限问题等。&lt;/p&gt;

&lt;p&gt;hbase 一个预分区 10GB  数据比较合理。&lt;/p&gt;

&lt;p&gt;maven 项目有hbase 的时候，JUnit 测试可能失败&lt;/p&gt;

&lt;p&gt;cassandra 导数据 nodetool disableautocompaction ，然后 enableautocompaction&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>neo4j存储结构分析</title>
      <link>https://dengziming.github.io/post/neo4j/neo4j%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/neo4j/neo4j%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</guid>
      
        <description>

&lt;h2 id=&#34;1-本文内容转自&#34;&gt;1.本文内容转自：&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://key-value-stories.blogspot.tw/2015/02/neo4j-architecture.html?view=magazine&#34;&gt;https://key-value-stories.blogspot.tw/2015/02/neo4j-architecture.html?view=magazine&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This post compiles some information about architecture of Neo4j, the leading graph database. Research is relevant for Neo4j 2.2 version.&lt;/p&gt;

&lt;p&gt;There are three main kinds of primitives in Neo4j: nodes, relationships and properties. Nodes are connected via relationships. Properties could be attached to both nodes and relationships. All primitives are identified by identifiers, unique among primitive kind.&lt;/p&gt;

&lt;p&gt;Node and relationship identifiers are 35 bits in length, i. e. database could hold at most about 34 billions of nodes or relationships. Property identifiers take 36 bits (reference).&lt;/p&gt;

&lt;p&gt;Also, relationships are typed (for example, &amp;ldquo;friend of&amp;rdquo; and &amp;ldquo;in relationship with&amp;rdquo; are two different types of relationships between &amp;ldquo;people nodes&amp;rdquo; in social network graph). Relationship types have 2-byte identifiers.&lt;/p&gt;

&lt;p&gt;In addition, nodes could be labelled. Label is logically another one kind of entity, with own identifiers.
Main data storage
Primitives stored on disk as records. Important, that all records or primitives of a kind are equally sized. (Actually, there are more record types and dedicated stores, and they all share this property. Dynamically sized data is stored as a linked list of constantly sized records.)
Node store format
Node records are 15 bytes (* 8 = 120 bits) long:
35 bits for first relationship identifier
36 bits for first property identifier
40 bytes for label field:
If there are at most 7 labels attached to the node, and each of label identifiers takes no more than (40 - 4  = 36) / numberOfLabels, i. e. if there are 7 labels, each label id should be below 2(36 / 7) = 5 = 32, than number of labels is stored in 36..38-th bits of the label field, and the label identifiers are packed in lower 0..35-th bits.
Otherwise, if there are more than 7 labels attached to the node, or their identifiers are too big, 39-th bit of the label field, i. e. the flag, is set, and in the lower 0..35-th bits of the label field the identifier of the dynamic record with all label ids is stored.
9 bits &amp;ndash; some flags and reserved for future use
Relationship store format
Since node keeps only a reference to the single relationship, relationships are orginized in doubly-linked lists, that makes all relationships of some node traversable from this node. Each relationship is a part of two linked lists: a list of relationships of the first node, i. e. from which this relationship starts, and a lists of relationships of the second node, i. e. at which this relationships ends.&lt;/p&gt;

&lt;p&gt;Relationship record take 34 bytes (* 8 = 272 bits):
35 bits of the first node identifier
35 bits of the second node identifier
35 * 4 = 140 bits of identifiers of the sibling relationships in two linked lists, this relationship participate in
16 bits of relationship type
36 bits for first property identifier
10 bits &amp;ndash; some flags and reserved for future use
Organazing relationships in linked lists is not particularly performant decision itself, but in some cases it becomes really disastrous &amp;ndash; for example, when some type of nodes has (on average) 100 relationships of type A and some relationships of type B. If we are only interested in traversal over relationships of type B, and they are occasionally clustered in the end of linked lists of the nodes of our type, we are required to traverse 100 relationships in which we are not currently interested to access the useful data.&lt;/p&gt;

&lt;p&gt;Apparently to optimize cases like explained above, Neo4j supports another relationship layout (called dense node), in a nutshell it links relationships of each node in a tree, rather than simple linked list. In this case, &amp;ldquo;first relationship identifier&amp;rdquo; is interpreted as an identifier of a relationship group. Each relationship group is dedicated to relationships of a certain type. Relationship group record is 25 bytes (* 8 = 200 bits) long:
35 bytes of the node identifier this relationship group belongs to
16 bits of relationship type
35 bytes of the first out relationship identifier, i. e. a relationship which has the given type and starts in the node owning this relationship group
35 bytes of the first in relationship identifier, i. e. a relationship which has the given type and ends in the node owning this relationship group
35 bytes of the first loop relationship identifier.
35 bytes of the next linked relationship group of the owning node, i. e. relationship groups form a singly-linked list
1 bit for presence flag
One more byte (8 bits) apparently reserved for future use, however I&amp;rsquo;m not sure, because seems that it would be nicer to fit 24 bytes for relationship group record, because it is more &amp;ldquo;power of 2 aligned&amp;rdquo;, i. e. plays better with cache lines, pages.
When relationship groups are used, relationships of any specified type and direction, could be traversed from from the node with much lesser overhead, skipping potentially a lot of relationships of the node we are not interested in during this traversal.&lt;/p&gt;

&lt;p&gt;There is an interesting small optimization: when the node is dense, first relationship records in the doubly-linked lists, to which relationship groups point, keep the length of the doubly-linked list in place of previous relationship link, which is otherwise unused (because first relationship in the doubly-linked list point only to the next relationship in a chain).
Property store format
As nodes and relationships reference only the first their property, they are also stored as doubly-linked lists, by owning primitive entity. Property record size is 41 bytes:
36 bits of the previous linked property identifier
36 bits of the next linked property identifier
32 bytes of &amp;ldquo;payload&amp;rdquo;, i. e. space where the property data itself is stored. It includes property type identifier, data encoding type and the data bytes. If the property data doesn&amp;rsquo;t fit the payload (i. e. it is a long string or array), the identifier of the linked dynamic data record is placed there as well.
Neo4j supports plenty of property data formats, trying to pack the data as dense as possible, but it is not the subject of this blog post.
File buffer cache
Records of different kinds are stored in separate files. Access to disk storage is proxied with file buffer cache, or page cache:
Neo4j uses multiple file buffer caches, one for each different storage file. Each file buffer cache divides its storage file into a number of equally sized windows. Each cache window contains an even number of storage records. The cache holds the most active cache windows in memory and tracks hit vs. miss ratio for the windows. When the hit ratio of an uncached window gets higher than the miss ratio of a cached window, the cached window gets evicted and the previously uncached window is cached instead.
Quote from Caches in Neo4j document.&lt;/p&gt;

&lt;p&gt;I would add, that the default page size is 8192 bytes, and it doesn&amp;rsquo;t depend on native page size, specified for the Neo4j server process, operation system or CPU platform.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t understand, why Neo4j developers don&amp;rsquo;t rely on OS file caches, which employ several heuristics, including LRU, to solve the same task. Probably user space implementation is more precise in decisions about page eviction, than native generic mechanism would be, and is more manageable, but, on the other hand,
Native page caching is fully transparent, i. e. relying on it simply throws a layer of complexity away from Neo4j project
Even with Java-level page cache, OS still caches the same pages underneath, i. e. work is doubled to some extent.
Summary
The approach to data storage, chosen in Neo4j has one very useful consequence: since all records are strictly of the same size, accessing records by identifiers is pretty cheap, because doesn&amp;rsquo;t require any associative mapping from identifiers to record locations (hash table, tree or something else), identifiers just play as indexes in &amp;ldquo;arrays&amp;rdquo; of records.&lt;/p&gt;

&lt;p&gt;Another strong point is impossibility of external fragmentation, records after removed primitives could always be reused.&lt;/p&gt;

&lt;p&gt;However, there are also major disadvantages:
Database entity identifiers hardly could simultaneously be domain identifiers, unless the system was designed to use Neo4j as primary storage from the beginning.
A lot of memory overhead for storing links between records. For example, 50-80% of 34-byte relationship record is overhead (depends on how to count).
Traversing links is slow. Partially it is excused by empirical observation, that if all relationships of the node or properties of the node or relationship are stored at once, they should reside adjacent records and their traversal won&amp;rsquo;t require page/cache line load on each step.
Neo4j&amp;rsquo;s storage design favor reliability, versatility, agility and manageability. Apparently it is driven by initial database functional requirements and equally powerful, but more efficient approach doesn&amp;rsquo;t exist (at least I don&amp;rsquo;t see such). There is a basic tradeoff in systems design: more specific and constrained systems could be implemented more efficiently, than general and schema-less, like Neo4j.
Indexes
Neo4j supports indexing of nodes and relationships by labels and property values, i. e. it allows retrieving all nodes with given label and/or property value faster, than via full scan of all nodes in the database.&lt;/p&gt;

&lt;p&gt;Apparently production implementation of indexes is fully delegated to Lucene engine. Entity identifiers are stored in Lucene documents with fields, corresponding to the indexed labels and property values. Lucene is able to search documents by individual fields and combinations of fields, empowering complex queries on Neo4j level.&lt;/p&gt;

&lt;p&gt;I can&amp;rsquo;t judge about propriety and efficiency of this solution, because I&amp;rsquo;m not familiar with Lucene implementation. This requires separate research.
Object cache
Neo4j is written in Java, known for allocation and GC issues. It has several versions of object caches, introduced to prevent too much unnecessary allocations of node, relationship and property wrapper objects. Note that Neo4j&amp;rsquo;s object caches are not object pools, i. e. objects are not reused, caches only control object&amp;rsquo;s lifecycle in managed memory environment (JVM).&lt;/p&gt;

&lt;p&gt;Community strong, weak and soft cache implementations use ConcurrentHashMap with Long keys and target cached object values. weak and soft versions additionally wrap values with WeakReference or SoftReference respectively. Object eviction is left to JVM. At least one obvious optimization is possible here: specialization of ConcurrentHashMap for primitive long keys.&lt;/p&gt;

&lt;p&gt;Enterprise hpc (high-performance cache) uses simpler data structure: basically it&amp;rsquo;s just an AtomicReferenceArray of cached entities, slot for particular entity is determined as entity.id() % array.length(). On collisions, old cached objects are evicted. Eviction algorithm is also very simple: when after insertion of the new object total memory footprint of cached objects (including JVM object headers), preserved in a counter, exceeds configured limit, slots before and after current insertion index are cleared (in interleaved order), while total size of the cached objects is higher than 90% of the limit size.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s an amusing example, how applying little knowledge about the problem and major usage patterns leads to faster solution, even with simpler implementation.
Conclusion
In my understanding, Neo4j is a reliable, agile, general-purpose database, but it is not for edge performance, despite claims on their official website. Databases that allow to specialize storage and data structures for concrete node/relationship types should be more efficient.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>neo4j导数据</title>
      <link>https://dengziming.github.io/post/neo4j/neo4j%E5%AF%BC%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/neo4j/neo4j%E5%AF%BC%E6%95%B0%E6%8D%AE/</guid>
      
        <description>

&lt;h2 id=&#34;1-修改配置&#34;&gt;1.修改配置&lt;/h2&gt;

&lt;p&gt;dbms.security.allow_csv_import_from_file_urls=true
&amp;ndash; load csv 命令&lt;/p&gt;

&lt;p&gt;dbms.directories.import=import&lt;/p&gt;

&lt;p&gt;restart neo4j&lt;/p&gt;

&lt;h3 id=&#34;2-导入数据方法1&#34;&gt;2.导入数据方法1&lt;/h3&gt;

&lt;p&gt;load csv with headers from &amp;ldquo;file:///path/to/file&amp;rdquo; as row
create (:Employee {employeeId:toInt(row.id),first_name:row,first_name,title:row.title });&lt;/p&gt;

&lt;h3 id=&#34;3-导入数据方法2&#34;&gt;3. 导入数据方法2&lt;/h3&gt;

&lt;p&gt;dbms.directories.import=/var/lib/neo4j/import/&lt;/p&gt;

&lt;p&gt;注释：&lt;/p&gt;

&lt;h1 id=&#34;dbms-security-allow-csv-import-from-file-urls-true&#34;&gt;dbms.security.allow_csv_import_from_file_urls=true&lt;/h1&gt;

&lt;p&gt;将文件放入 ：/var/lib/neo4j/import/  文件夹下，直接输入文件名即可：&lt;/p&gt;

&lt;p&gt;load csv with headers from &amp;ldquo;file:///filename&amp;rdquo; as row
create (:Employee {employeeId:toInt(row.id),first_name:row,first_name,title:row.title });&lt;/p&gt;

&lt;h3 id=&#34;4-初始化导数据&#34;&gt;4.初始化导数据&lt;/h3&gt;

&lt;p&gt;新建每个节点和关系的header文件和数据文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# vertex header
phone:ID(PHONE),isblack,ismedia,iscuishou
# edge header
:START_ID(USERID),:END_ID(PHONE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后导数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;neo4j-import \
 --into /data/neo4j/graph/all20180417.db \
 --skip-duplicate-nodes true \
 --skip-bad-relationships true \
 --ignore-extra-columns true \
 --ignore-empty-strings true \
 --bad-tolerance 10000000 \
  --processors 56 \
 --id-type string \
 --max-memory 170G \
--nodes:LBS &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_lbs.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_lbs.txt&amp;quot;  \
--nodes:IDCARD &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_idcard.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_idcard.txt&amp;quot;  \
--nodes:GNHID &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_gnhid.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_gnhid.txt&amp;quot;  \
--nodes:QQ &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_qq.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_qq.txt&amp;quot;  \
--nodes:WEIXIN &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_weixin.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_weixin.txt&amp;quot;  \
--nodes:EMAIL &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_email.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_email.txt&amp;quot;  \
--nodes:DEVICETOKEN &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_devicetoken.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_devicetoken.txt&amp;quot;  \
--nodes:COMPANY &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_company.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_company.txt&amp;quot;  \
--nodes:IP &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_ip.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_ip.txt&amp;quot;  \
--nodes:ORDERID &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_orderid.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_orderid.txt&amp;quot;  \
--nodes:USERID &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_userid.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_userid.txt&amp;quot;  \
--nodes:PHONE &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_phone.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_phone.txt&amp;quot;  \
--nodes:WIFI &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_v_wifi.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_v_wifi.txt&amp;quot;  \
--relationships:USERID_PHONE_EMG &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v3_e_userid_phone_emg.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v3_e_userid_phone_emg.txt&amp;quot;  \
--relationships:USERID_PHONE_LOAN &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v3_e_userid_phone_loan.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v3_e_userid_phone_loan.txt&amp;quot;  \
--relationships:USERID_COMPANY_LOAN &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v3_e_userid_company_loan.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v3_e_userid_company_loan.txt&amp;quot;  \
--relationships:USERID_LBS_LOAN &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v3_e_userid_lbs_loan.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v3_e_userid_lbs_loan.txt&amp;quot;  \
--relationships:USERID_DEVICETOKEN_LOAN &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v3_e_userid_devicetoken_loan.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v3_e_userid_devicetoken_loan.txt&amp;quot;  \
--relationships:USERID_LBS &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_lbs.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_lbs.txt&amp;quot;  \
--relationships:USERID_COMPANY_GJJ &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_company_gjj.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_company_gjj.txt&amp;quot;  \
--relationships:USERID_IDCARD &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v3_e_userid_idcard.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v3_e_userid_idcard.txt&amp;quot;  \
--relationships:USERID_COMPANY_GNH_USERS &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_company_gnh_users.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_company_gnh_users.txt&amp;quot;  \
--relationships:USERID_GNHID_USERS &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_gnhid_users.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_gnhid_users.txt&amp;quot;  \
--relationships:USERID_IP_GNH_USERS &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_ip_gnh_users.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_ip_gnh_users.txt&amp;quot;  \
--relationships:USERID_PHONE_GNH_EMG_USERS &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_phone_gnh_emg_users.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_phone_gnh_emg_users.txt&amp;quot;  \
--relationships:USERID_QQ_GNH_USERS &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_qq_gnh_users.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_qq_gnh_users.txt&amp;quot;  \
--relationships:ORDERID_IP_GNH_USERS &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_orderid_ip_gnh_users.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_orderid_ip_gnh_users.txt&amp;quot;  \
--relationships:USERID_ORDERID &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v3_e_userid_orderid.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v3_e_userid_orderid.txt&amp;quot; \
--relationships:USERID_DEVICETOKEN_RISKBRAIN_UMID &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_devicetoken_riskbrain_umid.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_devicetoken_riskbrain_umid.txt&amp;quot; \
--relationships:USERID_DEVICETOKEN_USER_DEVICES &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_devicetoken_t_user_devices.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_devicetoken_t_user_devices.txt&amp;quot; \
--relationships:USERID_DEVICETOKEN_USER_EVENT &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_devicetoken_user_event.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_devicetoken_user_event.txt&amp;quot; \
--relationships:USERID_COMPANY_USER_INFO_EXT &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_company_user_info_ext.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_company_user_info_ext.txt&amp;quot; \
--relationships:USERID_IP_CUSTINFO &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_ip_custinfo.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_ip_custinfo.txt&amp;quot; \
--relationships:USERID_IP_USER_EVENT &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_ip_user_event.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_ip_user_event.txt&amp;quot; \
--relationships:USERID_EMAIL_USER_EVENT &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_email_user_event.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_email_user_event.txt&amp;quot; \
--relationships:USERID_EMAIL_EXTMAIL_USER_MAILACCOUNT &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_email_user_mailaccount.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_email_user_mailaccount.txt&amp;quot; \
--relationships:USERID_QQ_USER_EVENT &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_qq_user_event.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_qq_user_event.txt&amp;quot; \
--relationships:USERID_WEIXIN_USER_EVENT &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_weixin_user_event.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_weixin_user_event.txt&amp;quot; \
--relationships:USERID_PHONE_USER_EVENT &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_phone_user_event.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_phone_user_event.txt&amp;quot; \
--relationships:USERID_PHONE_CUSTINFO &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_phone_custinfo.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_phone_custinfo.txt&amp;quot; \
--relationships:USERID_PHONE_USERCENTER &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_phone_usercenter.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_phone_usercenter.txt&amp;quot; \
--relationships:USERID_PHONE_USER_EMG_CONTACT &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_phone_user_emg_contact.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_phone_user_emg_contact.txt&amp;quot; \
--relationships:USERID_PHONE_TEL &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v3_e_userid_phone_tel.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v3_e_userid_phone_tel.txt&amp;quot; \
--relationships:USERID_PHONE_CONTACT &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_phone_contact.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_phone_contact.txt&amp;quot; \
--relationships:PHONE_PHONE_TEL &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v3_e_phone_phone_tel.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v3_e_phone_phone_tel.txt&amp;quot; \
--relationships:PHONE_PHONE_CONTACT &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_phone_phone_contact.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_phone_phone_contact.txt&amp;quot; \
--relationships:USERID_WIFI &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_userid_wifi.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_userid_wifi.txt&amp;quot; \
--relationships:ORDERID_WIFI &amp;quot;/data1/neo4j/data/offline/graph_kg/header/kg_v2_e_orderid_wifi.txt,/data1/neo4j/data/offline/graph_kg/data/kg_v2_e_orderid_wifi.txt&amp;quot; \
          &amp;gt; /data/neo4j/graph/all20180417.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>常用maven命令</title>
      <link>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/maven%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/maven%E5%91%BD%E4%BB%A4/</guid>
      
        <description>

&lt;h2 id=&#34;一&#34;&gt;一、&lt;/h2&gt;

&lt;h3 id=&#34;1-插件&#34;&gt;1.插件&lt;/h3&gt;

&lt;p&gt;版本兼容检查&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;plugin&amp;gt;
  &amp;lt;groupId&amp;gt;org.revapi&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;revapi-maven-plugin&amp;lt;/artifactId&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码风格检查&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;maven-checkstyle-plugin
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-常见异常&#34;&gt;2.常见异常&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;
cached in local repository &amp;hellip;
这个原因可能是上一次更新失败，会有一个update文件放在本地，去repository对应目录删除即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;也有可能是打的包是 war 包不是jar包，复制一份，改名为 .jar 即可。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;can&amp;rsquo;t find jar in alimaven， 这个原因是仓库可能没这个jar，可是换一个仓库。
例如换成开源中国的仓库，但是可能又有新的错误，最好是使用 -rf 从某一个重新开始打包 &lt;code&gt;mvn clean install -DskipTests=true -rf :janusgraph-es&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;java return cannot find symbol com.sun.*
可以换成 jdk1.8.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Missing tools.jar at: /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/Classes/classes.jar. Expression: file.exists()&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;原因，maven 的配置文件的 profiles 中有个 profile：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;profile&amp;gt;
  &amp;lt;id&amp;gt;osx-jdk&amp;lt;/id&amp;gt;
  &amp;lt;activation&amp;gt;
    &amp;lt;file&amp;gt;
      &amp;lt;exists&amp;gt;${java.home}/../Classes/classes.jar&amp;lt;/exists&amp;gt;
    &amp;lt;/file&amp;gt;
  &amp;lt;/activation&amp;gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;jdk.tools&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jdk.tools&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;system&amp;lt;/scope&amp;gt;
      &amp;lt;version&amp;gt;1.6&amp;lt;/version&amp;gt;
      &amp;lt;systemPath&amp;gt;${java.home}/../Classes/classes.jar&amp;lt;/systemPath&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
&amp;lt;/profile&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;activation 代表使用条件，${java.home} 代表 JRE 目录，如果这个文件存在就是用 osx-jdk。现在是因为这个文件不存在，所以只要让这个文件存在即可。&lt;/p&gt;

&lt;p&gt;解决办法：&lt;a href=&#34;https://stackoverflow.com/questions/23971229/maven-install-hadoop-from-source-looking-in-the-wrong-path-for-tools-jar&#34;&gt;https://stackoverflow.com/questions/23971229/maven-install-hadoop-from-source-looking-in-the-wrong-path-for-tools-jar&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;cd /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/
sudo mkdir Classes
cd Classes/
sudo ln -s ../jre/lib/rt.jar classes.jar&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
neo4j-3.4/community/dbms/src/main/java/org/neo4j/dbms/diagnostics/jmx/LocalVirtualMachine.java:[23,28] package com.sun.tools.attach does not exist&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个和上面的错误很类似，上面的错误是因为我们通过在 jre 目录下面做了一个软连接，把 rt.jar 连接到了 classes.jar，classes.jar 包中没有 com.sun.tools.attach，而它需要的是 tools.jar，&lt;/p&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;p&gt;cd /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/
sudo rm -rf Classes/classes.jar
sudo ln -s lib/tools.jar Classes/classes.jar&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;not found: type InputPosition
not found: value Eagerly&lt;/p&gt;

&lt;p&gt;解决方案：
一般是 scala 编译器没配置好。重新设置。
有时候 IDEA 运行没问题，但是打包报这个问题，解决方案？
目前不知道，重新 import 后，找个类运行一下，然后再打包就成功了。&lt;/p&gt;

&lt;p&gt;mvn -settings ~/opt/soft/apache-maven-3.5.0/conf/settings.xml -Dlicense.skip=true -DskipTests package install -rf :neo4j-cypher-util-3.4&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
inspect a maven model for resolution&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Maven -&amp;gt; Reimport&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;
/Users/dengziming/opt/sourcecode/neo4j-3.4/community/cypher/interpreted-runtime/src/test/scala/org/neo4j/cypher/internal/runtime/interpreted/commands/ComparablePredicateTest.scala:53: warning: a type was inferred to be &lt;code&gt;Any&lt;/code&gt;; this may indicate a programming error.
[ERROR]     case v: Number if v.doubleValue().isNaN =&amp;gt; Seq(v.doubleValue(), v.floatValue(), v)
[ERROR]          ^&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个问题好像没造成停止。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;应用A直接应用B，应用B依赖二方包C1、C2、C3，应用A传递依赖C1、C2、C3。现应用B升级版本，应用更新B依赖包后发现可正常引入依赖B，但传递依赖的C1、C2、C3不能引入。
　　
&lt;a href=&#34;https://blog.csdn.net/xktxoo/article/details/78005817&#34;&gt;https://blog.csdn.net/xktxoo/article/details/78005817&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打包不包含 scala 编译文件，pom 的 build 中缺少打包scala的插件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;java 调用 scala 代码不报错，打包报错。
参考 &lt;a href=&#34;http://xflin.blogspot.com/2013/08/mixed-scala-and-java-in-maven-project.html&#34;&gt;http://xflin.blogspot.com/2013/08/mixed-scala-and-java-in-maven-project.html&lt;/a&gt; ，混合编译&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;3-常用命令&#34;&gt;3.常用命令&lt;/h3&gt;

&lt;p&gt;mvn -pl hadoop-yarn-project -am clean install -D maven.test.skip=true -P prod&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>常用sql写法</title>
      <link>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/janus/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/janus/</guid>
      
        <description>

&lt;h2 id=&#34;sql语法&#34;&gt;sql语法&lt;/h2&gt;

&lt;p&gt;2）删库前，执行/sdc/node1/bin/nodetool compactionstats  看下当前有没跟要删除相关的Compaction任务，如果有就执行 /sdc/node1/bin/nodetool stop命令中止,  这个是每个节点都要确认.
3)  drop keyspace后，最好删除磁盘上的物理目录, 防止复用时有影响.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>常用sql写法</title>
      <link>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/sql/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/sql/</guid>
      
        <description>

&lt;h2 id=&#34;sql语法&#34;&gt;sql语法&lt;/h2&gt;

&lt;p&gt;每个语言的语法不一样，大致类似。&lt;/p&gt;

&lt;h3 id=&#34;1-调优经验&#34;&gt;1. 调优经验&lt;/h3&gt;

&lt;p&gt;可以先explain，分析一下。然后再运行。&lt;/p&gt;

&lt;p&gt;join可能会导致数据倾斜的情况：&lt;/p&gt;

&lt;p&gt;join的key是不均匀的，
join的key有很多事空值，这时候可以分为两部分进行union&lt;/p&gt;

&lt;p&gt;多表join：
一般是前面的stage一起执行，最后有一个stage。
如果发现很慢，数据也没有倾斜，可能是某些表的key重复，导致join会有笛卡尔积操作，得到很多数据所以慢，可以根据业务进行过滤。&lt;/p&gt;

&lt;h2 id=&#34;常用sql&#34;&gt;常用sql&lt;/h2&gt;

&lt;h3 id=&#34;1-不等值join&#34;&gt;1.不等值join&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;
cache table b as select * from location ;

select
    a.ip,
    b.city
from
    b
RIGHT JOIN
    fin_kg.kg_v2_v_ip a
ON
    a.ip &amp;gt;= b.ip_start
AND
    a.ip &amp;lt;= b.ip_end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CACHE TABLE chuanxiao AS SELECT id,name,regs FROM vdm_fin.chuanxiao_20180417;

insert overwrite table kg_v2_e_userid_gang
select
    b.id,
    b.name,
    a.phone,
    a.contact_phone,
    a.contact_name
from
     a
right join
    chuanxiao b
on
    a.contact_name regexp regexp_replace(b.regs,&amp;quot;%&amp;quot;,&amp;quot;.*&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改null存储为&amp;rdquo;,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;ROW FORMAT DELIMITED
      FIELDS TERMINATED BY &#39;,&#39;
      LINES TERMINATED BY &#39;\n&#39;
      NULL DEFINED AS &#39;&#39;
     stored as textfile;
     
alter table fin_kg.kg_v2_e_phone_gang_bak SET SERDEPROPERTIES (&#39;serialization.null.format&#39;=&#39;&#39;); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-分位点&#34;&gt;2.分位点&lt;/h3&gt;

&lt;p&gt;percentile
percentile_approx
percentile_rank&lt;/p&gt;

&lt;h3 id=&#34;3-保留小数&#34;&gt;3.保留小数&lt;/h3&gt;

&lt;p&gt;printf&lt;/p&gt;

&lt;h3 id=&#34;4-手动刷新impala元数据&#34;&gt;4. 手动刷新impala元数据&lt;/h3&gt;

&lt;p&gt;invalidate metadata [tablename]&lt;/p&gt;

&lt;h3 id=&#34;5-键值对&#34;&gt;5.键值对&lt;/h3&gt;

&lt;p&gt;str_to_map(concat_ws(&amp;lsquo;,&amp;rsquo;,collect_set(concat_ws(&amp;rsquo;:&amp;lsquo;, ctime_month, cast(final_score as string) )))) as time2score&lt;/p&gt;

&lt;h3 id=&#34;6-cache-table&#34;&gt;6.cache table&lt;/h3&gt;
</description>
      
    </item>
    
    <item>
      <title>常用正则表达式</title>
      <link>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      
        <description>

&lt;h2 id=&#34;正则语法&#34;&gt;正则语法&lt;/h2&gt;

&lt;p&gt;每个语言的语法不一样，大致类似。&lt;/p&gt;

&lt;h3 id=&#34;1&#34;&gt;1.&lt;/h3&gt;

&lt;h2 id=&#34;常用正则&#34;&gt;常用正则&lt;/h2&gt;

&lt;h3 id=&#34;1-nginx匹配&#34;&gt;1.nginx匹配&lt;/h3&gt;

&lt;p&gt;([^\s]+) - ([.+])&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 
&#39;([^\\s]+) - (\\[.+\\])&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释：
\转义，这里加上sql转义是两个转义。
括号括起来是一个字符集
. 代表任意字符，+代表至少一次（*为任意次，？为最多一次）&lt;/p&gt;

&lt;h3 id=&#34;2-字符串分割&#34;&gt;2.字符串分割&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT split(&#39;%180%霖易%|%180%商城%|%霖易商城%&#39;,&#39;\\|&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;|代表或，如果分割需要转义。&lt;/p&gt;

&lt;h3 id=&#34;3-特殊字符替换&#34;&gt;3.特殊字符替换&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT   regexp_replace(&#39;(名字)。|得到的sssa》《？&#39;,&#39;\\(.*?\\)|[^(a-zA-Z0-9\\u2E80-\\u9FFF)]|[\\( \\)《》。，〈〉、⼂\\⼁]|\\s+|,|&amp;quot;|\&#39;&#39;,&#39;&#39;) as contact_name

-- 得到的sssa
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-scala-匹配写法&#34;&gt;4.scala 匹配写法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;val relation1_1: Regex = &amp;quot;.*(宝贝|亲爱).*&amp;quot;.r
  val relation1_2 = &amp;quot;^[老]?[爸|妈|爹|娘].*&amp;quot;.r
  val relation1_3 = &amp;quot;^(老婆|妻子|媳妇|老公|丈夫|儿子|女儿|老[头爷]子|丈母娘|丈人|婆婆|内人|内子|太太|夫人|外子|爱人).*&amp;quot;.r
  val relation2_1 = &amp;quot;^[大小二三四五六七八九十]?[哥兄弟姐妹伯叔姑婶舅姨].*&amp;quot;.r
  val relation2_2 = &amp;quot;^[爷奶].*&amp;quot;.r
  val relation2_3 = &amp;quot;^老[大二三四五六七八九十].*&amp;quot;.r
  val relation3_1 = &amp;quot;.*(先生|老板|老板娘|小姐|女士|总$|经理$).*&amp;quot;.r
  val relation4_1 = &amp;quot;.*(老师).*&amp;quot;.r
  val relation5_1 = &amp;quot;.*(同学).*&amp;quot;.r
  val relation6_1 = &amp;quot;^老.*&amp;quot;.r
  val relation7_1 = &amp;quot;.*(提额|大额|高额|白户|黑户|额度|面签|信用|消费|金融|融资|款|借|POS|套现).*&amp;quot;.r
  val relation7_2 = &amp;quot;.*(贷|中介).*&amp;quot;.r
  val relation7_3 = &amp;quot;.*(办|刷|养).*&amp;quot;.r
  val relation7_4 = &amp;quot;.*(代).*&amp;quot;.r

  def getRelationByName(name:String): Int ={

    name match {

      case relation1_1(_) =&amp;gt; 1
      case relation1_2() =&amp;gt; 1
      case relation1_3(_) =&amp;gt; if (name.contains(&amp;quot;的&amp;quot;)) 0 else 1
      case relation2_1() =&amp;gt; 2
      case relation2_2() =&amp;gt; 2
      case relation2_3() =&amp;gt; 2
      case relation3_1(_) =&amp;gt; 3
      case relation4_1(_) =&amp;gt; 4
      case relation5_1(_) =&amp;gt; 5
      case relation6_1() =&amp;gt; 6
      case relation7_1(_) =&amp;gt; 7
      case relation7_2(_) =&amp;gt; if (name.contains(&amp;quot;房&amp;quot;)) 0 else 7
      case relation7_3(_) =&amp;gt; if (name.contains(&amp;quot;卡&amp;quot;)) 7 else 0
      case relation7_4() =&amp;gt; if (name.contains(&amp;quot;办&amp;quot;)) 7 else 0
      case _ =&amp;gt; 0
    }
  }
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://dengziming.github.io/post/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      
        <description>

&lt;h2 id=&#34;一-过滤器模式&#34;&gt;一、过滤器模式&lt;/h2&gt;

&lt;p&gt;过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。&lt;/p&gt;

&lt;p&gt;mongo 的查询接口有很多方法，例如 and，or，实际上就是串在一起。&lt;/p&gt;

&lt;h2 id=&#34;二-组合模式&#34;&gt;二、组合模式&lt;/h2&gt;

&lt;p&gt;树枝内部组合该接口，并且含有内部属性 List，里面放 Component。叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Employee {
   private String name;
   private String dept;
   private int salary;
   private List&amp;lt;Employee&amp;gt; subordinates;
 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;三-装饰器模式&#34;&gt;三、装饰器模式&lt;/h2&gt;

&lt;p&gt;类似适配器，代理，桥接&lt;/p&gt;

&lt;p&gt;java 的 IO 包就是典型代表&lt;/p&gt;

&lt;h2 id=&#34;四-外观模式&#34;&gt;四、外观模式&lt;/h2&gt;

&lt;p&gt;为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。不符合开放封闭原则，如果要改东西很麻烦。&lt;/p&gt;

&lt;h2 id=&#34;五-桥接模式&#34;&gt;五、桥接模式&lt;/h2&gt;

&lt;p&gt;抽象类依赖实现类。&lt;/p&gt;

&lt;h2 id=&#34;六-责任链模式&#34;&gt;六、责任链模式&lt;/h2&gt;

&lt;p&gt;拦截器模式：以 Logger 为例，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public abstract class AbstractLogger {
protected AbstractLogger nextLogger;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;七-观察者模式&#34;&gt;七、观察者模式&lt;/h2&gt;

&lt;p&gt;微博动态可以设计成观察者模式，每个人记录自己的观察者，发送的时候通知。&lt;/p&gt;

&lt;h2 id=&#34;八-策略模式&#34;&gt;八、策略模式&lt;/h2&gt;

&lt;p&gt;诸葛亮的锦囊妙计，每一个锦囊就是一个策略。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>资料地址</title>
      <link>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E8%B5%84%E6%96%99%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/%E8%B5%84%E6%96%99%E5%9C%B0%E5%9D%80/</guid>
      
        <description>

&lt;h2 id=&#34;常用&#34;&gt;常用&lt;/h2&gt;

&lt;p&gt;kafka reset offset
&lt;a href=&#34;https://gist.github.com/marwei/cd40657c481f94ebe273ecc16601674b&#34;&gt;https://gist.github.com/marwei/cd40657c481f94ebe273ecc16601674b&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;数据库底层原理
&lt;a href=&#34;http://coding-geek.com/how-databases-work/&#34;&gt;http://coding-geek.com/how-databases-work/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;hashMap
&lt;a href=&#34;http://coding-geek.com/how-databases-work/&#34;&gt;http://coding-geek.com/how-databases-work/&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>面向对象经验</title>
      <link>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/oop/</link>
      <pubDate>Thu, 22 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dengziming.github.io/post/%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C/oop/</guid>
      
        <description>&lt;p&gt;用面向对象方法开发软件，通常需要建立3种形式的模型它们分别是：描述系统数据结构的对象模型、描述系统控制结构的动态模型和描述系统功能的功能模型。&lt;/p&gt;

&lt;p&gt;面向对象的软件工程主要包括以下部分：&lt;/p&gt;

&lt;p&gt;1) 面向对象分析（object oriented analysis，OOA）;&lt;/p&gt;

&lt;p&gt;2) 面向对象设计（object oriented design，OOD）;&lt;/p&gt;

&lt;p&gt;3) 面向对象编程（object oriented programming，OOP）;&lt;/p&gt;

&lt;p&gt;4) 面向对象测试（object oriented test，OOT）;&lt;/p&gt;

&lt;p&gt;5) 面向对象维护（object oriented soft maintenance,OOSM）;&lt;/p&gt;

&lt;p&gt;源码分析统计扫描所有代码并且展示类之间的关系。市场上有很多设备与工具。比如：Architexa， AgileJ， UModel， Poseidon等。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>